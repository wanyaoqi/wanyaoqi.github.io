<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yaoqi&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9b56c310f2d1c05e0d67ae7ff77d9d75</icon>
  <subtitle>coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanyaoqi.top/"/>
  <updated>2018-04-06T07:20:03.000Z</updated>
  <id>http://wanyaoqi.top/</id>
  
  <author>
    <name>wanyaoqi</name>
    <email>wanyaoqi1995@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RPM 使用与 SPEC 文件</title>
    <link href="http://wanyaoqi.top/2018/03/18/rpm_spec/"/>
    <id>http://wanyaoqi.top/2018/03/18/rpm_spec/</id>
    <published>2018-03-18T08:22:20.000Z</published>
    <updated>2018-04-06T07:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>RPM全称是 Red Hat Package Manager（Red Hat包管理器）。</p><p>RPM的发布基于GPL协议（GNU通用公共授權條款GNU General Public License，简称GNU <em>GPL</em>、<em>GPL</em>）。</p><p>RPM有五种基本的操作功能(不包括创建软件包)：安装、卸载、升级、查询、和验证。关于rpm命令的使用我们可以用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@serverwyq wyq]# rpm --help</span><br></pre></td></tr></table></figure><p>​   通常，供Linux使用的源代码包还提供一个名为 <strong>{ 软件名称 }.spec</strong> 的文件，即spec文件。如果提供spec文件，则该源代码还可以直接编译成RPM包。 </p><h2 id="2-RPM-使用"><a href="#2-RPM-使用" class="headerlink" title="2. RPM 使用"></a>2. RPM 使用</h2><h3 id="1）安装"><a href="#1）安装" class="headerlink" title="1）安装"></a>1）安装</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE ...</span><br></pre></td></tr></table></figure><p>​   通过rpm -ivh可以把rpm软件包安装到系统中，使用的较多的是-ivh参数 ，使用该选项可以解决大部分rpm软件包的安装，至于详细的参数说明可用查看rpm的man 文档。</p><h3 id="2）卸载"><a href="#2）卸载" class="headerlink" title="2）卸载"></a>2）卸载</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-e|--erase&#125; [--allmatches] [--nodeps] [--noscripts]</span><br><span class="line">           [--notriggers] [--test] PACKAGE_NAME ...</span><br><span class="line">           </span><br><span class="line">注：</span><br><span class="line">--nodeps  Don’t do a dependency check before installing or upgrading a package.(不检查依赖)</span><br><span class="line">--force   Same as using --replacepkgs, --replacefiles, and --oldpackage.(相当于同时使用了这三个参数)</span><br><span class="line"></span><br><span class="line">--replacepkgs</span><br><span class="line">      Install the packages even if some of them are already installed on this system.</span><br><span class="line">--replacefiles</span><br><span class="line">      Install the packages even if they replace files from other, already installed, packages.</span><br></pre></td></tr></table></figure><p>​   如果某个软件包你再也不想使用了，那就用以上这个命令彻底的把你指定的rpm软件包清除掉把。</p><h3 id="3）升级"><a href="#3）升级" class="headerlink" title="3）升级"></a>3）升级</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ...</span><br></pre></td></tr></table></figure><p>​   由于开源软件更新速度快，用户当然要使用最新版本的软件包，此时最合适的就是rpm升级功能，当然最理想的参数选项就是-Uvh。</p><h3 id="4）查询"><a href="#4）查询" class="headerlink" title="4）查询"></a>4）查询</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-q|--query&#125; [select-options] [query-options]</span><br></pre></td></tr></table></figure><p>​   查看软件包的版本、依赖关系等软件包的详细说明都要用到这个选项，常用的有：</p><p> <strong>rpm -qa</strong> 是查询机器上所有已经安装的包，加上grep可以得到你想要的包名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@serverwyq wyq]# rpm -qa | grep kernel</span><br><span class="line">kernel-...</span><br><span class="line">kernel-devel-...</span><br><span class="line">kernel-headers-...</span><br></pre></td></tr></table></figure><p><strong>rpm -qi</strong>   + 包名  == 查看包的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@serverwyq wyq]# rpm -qi kernel-3.10.0-123.el7.x86_64                                                                                                                                </span><br><span class="line">Name        : kernel</span><br><span class="line">Install Date: 2014年07月09日 星期三 13时57分38秒</span><br><span class="line">......</span><br><span class="line">URL         : http://www.kernel.org/</span><br><span class="line">Summary     : The Linux kernel</span><br></pre></td></tr></table></figure><p><strong>rpm -ql</strong> + 包名 == 查看包内文件的安装路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@serverwyq wyq]# rpm -ql kernel-3.10.0-123.el7.x86_64 |more                                                                                                                            </span><br><span class="line">/boot/.vmlinuz-3.10.0-123.el7.x86_64.hmac</span><br><span class="line">/boot/System.map-3.10.0-123.el7.x86_64</span><br><span class="line">/boot/config-3.10.0-123.el7.x86_64</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="5）校验"><a href="#5）校验" class="headerlink" title="5）校验"></a>5）校验</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-V|--verify&#125; [select-options] [verify-options]</span><br></pre></td></tr></table></figure><p>​   一般我们可用通过该命令来验证已安装软件包</p><h3 id="6）解压"><a href="#6）解压" class="headerlink" title="6）解压"></a>6）解压</h3><p>​   RPM包是使用cpio格式打包的，因此需要先转成cpio然后解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio some.rpm | cpio -div</span><br></pre></td></tr></table></figure><h2 id="3-spec文件"><a href="#3-spec文件" class="headerlink" title="3. spec文件"></a>3. spec文件</h2><p>​   其实，制作RPM软件包并不是一件复杂的工作，其中的关键在于编写SPEC软件包描述文件。</p><p>​   这个文件中包含了软件包的诸多信息，如软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。</p><p>​   像前面rmp -qi所看的信息都是制作rpm包时在spec文件中指定的。</p><h4 id="1）Preamle"><a href="#1）Preamle" class="headerlink" title="1）Preamle"></a>1）Preamle</h4><p>​   序言包含用户请求包的信息时所显示的内容。它可以包含包的功能描述、包的软件版本、版权信息和所属的包组等。Summary 是一行关于该软件包的描述，Name 是该软件包的基名，Version 是该软件的版本号，                                 Release 是 RPM 本身的版本号，如果修复了 spec 文件中的一个错误并发布了该软件同一版本的新 RPM，就应该增加发行版号。License 应该给出一些许可说明，Group 标识软件类型。那些试图帮助人们管理 RPM 的程序通常按照组列出 RPM。您可以在/usr/share/doc/rpm-x.x.x/GROUPS 文件看到一个 Red Hat 使用的组列表。但是您还可以使用那些组名以外的名称。Source0、Source1等等给这些源文件命名（通常为 tar.gz 文件）。%{name} 和 %{version} 是 RPM 宏，它们扩展成为头中定义的 rpm 名称和版本。</p><p>​   要注意的是，<strong>不要在 Source 语句中包含任何路径</strong>。缺省情况下，RPM 会在 /usr/src/redhat/SOURCES 中（对于Redhat6 系统，则是在 /root/rpmbuild/SOURCES 目录中）寻找文件，请将您的源文件复制或链接到那里。（要使 spec 文件尽量可移植的话，应当尽量避免嵌入自己开发机器上的假想路径。其他开发人员就可以指示 RPM 在别的目录下查找源文件，而不用修改您的 spec 文件。）</p><p>​   接下来的部分从 %description 行开始。您应该在这里提供该软件更多的描述，这样任何人使用 rpm -qi 查询您的软件包时都可以看到它。您可以解释这个软件包做什么，描述任何警告或附加的配置指令，等等。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Summary: Utilities for managing accounts and shadow password files.</span><br><span class="line">Name: shadow-utils</span><br><span class="line">Version: 4.0.17</span><br><span class="line">Release: 14<span class="comment">%&#123;?dist&#125;</span></span><br><span class="line"> </span><br><span class="line">Source0: <span class="comment">%&#123;name&#125;-%&#123;version&#125;.tar.bz2</span></span><br><span class="line">Source1: shadow-4.0.17-login.defs</span><br><span class="line">Source2: shadow-970616.useradd</span><br><span class="line"> </span><br><span class="line">Patch0: shadow-4.0.17-redhat.patch</span><br><span class="line">Patch1: shadow-4.0.3-noinst.patch</span><br><span class="line">Patch2: shadow-4.0.11.1-vipw.patch</span><br><span class="line"> </span><br><span class="line">Packager:amoblin  </span><br><span class="line">Group: Application  </span><br><span class="line">URL: http://www.ossxp.com </span><br><span class="line">License: GPL</span><br><span class="line">BuildRequires: autoconf, automake, libtool, gettext-devel</span><br><span class="line">BuildRequires: libselinux-devel &gt;= 1.25.2-1</span><br><span class="line">BuildRequires: audit-libs-devel &gt;= 1.0.10</span><br><span class="line">Requires: libselinux &gt;= 1.25.2-1</span><br><span class="line"> </span><br><span class="line"><span class="comment">%description</span></span><br><span class="line">This package includes the necessary programs for XXX.</span><br></pre></td></tr></table></figure><h4 id="2）Prep"><a href="#2）Prep" class="headerlink" title="2）Prep"></a>2）Prep</h4><p>Prep 部分进行实际的打包准备工作，它是使用节前缀%prep表示的。主要功能有：<br>​   1. 将文件 (SOURCES/) 解压到构建目录 (BUILD/)<br>​   2. 应用Patch（打补丁） (SOURCES/ =&gt; BUILD/)<br>​   3. 描述 “rm -rf $RPM_BUILD_ROOT”<br>​   4. 描述或编辑本部分用到的命令到 PreReq:<br>​   5. 通过 “-b .XXX” 描述补丁备份</p><p>%setup</p><p>-n newdir #将压缩的软件源程序在newdir目录下解开。<br>-c #在解开源程序之前先创建目录。<br>-b num #在包含多个源程序时，将第num个源程序解压缩。<br>-T #不使用缺省的解压缩操作。</p><p>通常patch补丁都会一起放到SOURCES目录下。一般参数为<br>%patchN -p1 #应用前面定义的第N个patch，-p1是忽略patch的第一层目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%setup -q   #最常用</span><br><span class="line">%setup -q -n newdir    #将source解压至newdir</span><br><span class="line">%setup -T -b 0    #解开第一个源程序文件</span><br><span class="line">%setup -c -n newdir    #创建目录newdir，并在此目录之下解开源程序</span><br><span class="line"> </span><br><span class="line">%patch1 -p1   #应用第1个补丁</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%prep</span></span><br><span class="line"><span class="comment">%setup -q</span></span><br><span class="line"><span class="comment">%patch0 -p1</span></span><br><span class="line"><span class="comment">%patch1 -p1</span></span><br><span class="line"><span class="comment">%patch2 -p1</span></span><br><span class="line"><span class="comment">%patch3 -p1</span></span><br><span class="line"> </span><br><span class="line">cp <span class="comment">%&#123;SOURCE3&#125; lib/nscd.c</span></span><br><span class="line">rm po/*.gmo</span><br><span class="line">rm po/stamp-po</span><br></pre></td></tr></table></figure><h4 id="3）Build"><a href="#3）Build" class="headerlink" title="3）Build"></a>3）Build</h4><p>主要用于编译源码，它是使用节前缀%build表示的。一般用于configure及make的过程。</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%build</span><br><span class="line">%configure --with-selinux  --without-libpam --disable-shared --with-libaudit</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h4 id="4）install"><a href="#4）install" class="headerlink" title="4）install"></a>4）install</h4><p>这一节主要用于完成实际安装软件必须执行的命令，它是使用节前缀%install表示的。这一节一般是由make install指令构成，但是有时也会包含cp、mv、install等指令。</p><p>这一节还能指定在用户安装的系统上，包安装时运行的脚本。这样的脚本称为安装（卸载）脚本。它可以指定包安装前、包安装后、包除去前、包除去后的系统必须运行的外壳程序段。在用户安装的系统上，为了验证一个包是否已经成功安装的验证脚本也可由这一节指定。</p><p>eg:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%install</span></span><br><span class="line">rm -rf <span class="formula">$RPM_BUILD_ROOT</span></span><br><span class="line"><span class="formula">make install DESTDIR=$</span>RPM_BUILD_ROOT gnulocaledir=<span class="formula">$RPM_BUILD_ROOT/%&#123;_datadir&#125;/locale MKINSTALLDIRS=`pwd`/mkinstalldirs</span></span><br><span class="line"><span class="formula">install -d -m 755 $</span>RPM_BUILD_ROOT/etc/default</span><br><span class="line">install -c -m 0644 <span class="comment">%&#123;SOURCE1&#125; $RPM_BUILD_ROOT/etc/login.defs</span></span><br><span class="line">install -c -m 0600 <span class="comment">%&#123;SOURCE2&#125; $RPM_BUILD_ROOT/etc/default/useradd</span></span><br><span class="line"> </span><br><span class="line">ln -s useradd <span class="formula">$RPM_BUILD_ROOT%&#123;_sbindir&#125;/adduser</span></span><br><span class="line"><span class="formula">ln -s %&#123;_mandir&#125;/man8/useradd.8 $</span>RPM_BUILD_ROOT/<span class="comment">%&#123;_mandir&#125;/man8/adduser.8</span></span><br><span class="line">for subdir in <span class="formula">$RPM_BUILD_ROOT/%&#123;_mandir&#125;/&#123;??,??_??,??_??.*&#125;/man* ; do</span></span><br><span class="line"><span class="formula">        test -d $</span>subdir &amp;&amp; test -e <span class="formula">$subdir/useradd.8 &amp;&amp; echo ".so man8/useradd.8" &gt; $</span>subdir/adduser.8</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line"># Remove binaries we don't use.</span><br><span class="line">rm <span class="formula">$RPM_BUILD_ROOT/%&#123;_bindir&#125;/chfn</span></span><br><span class="line"><span class="formula">rm $</span>RPM_BUILD_ROOT/<span class="comment">%&#123;_bindir&#125;/chsh</span></span><br></pre></td></tr></table></figure><h4 id="5）clean"><a href="#5）clean" class="headerlink" title="5）clean"></a>5）clean</h4><p>这一节所描述的内容表示在完成包建立的工作之后，自动执行此节下的脚本进行附加的清除工作，它是使用节前缀%clean表示的。一般而言，这一节的内容是简单地使用rm -rf $RPM_BUILD_ROOT命令，不需要指定此节的其它内容。</p><p>eg:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%clean</span></span><br><span class="line">rm -rf <span class="formula">$RPM_BUILD_ROOT</span></span><br></pre></td></tr></table></figure><h4 id="6）files"><a href="#6）files" class="headerlink" title="6）files"></a>6）files</h4><p>这一节指定构成包的文件的列表，它是使用节前缀%files表示的。此外，它还包含一系列宏控制安装后的文件属性和配置信息。</p><p>%files 列出应该捆绑到 RPM 中的文件，并能够可选地设置许可权和其它信息。在 %files 中，您可以使用 %defattr 来定义缺省的许可权、所有者和组；%defattr(-,root,root) 会安装 root 用户拥有的所有文件，使用当 RPM 从构建系统捆绑它们时它们所具有的任何许可权。</p><p>可以用 %attr(permissions,user,group) 覆盖个别文件的所有者和许可权。可以在 %files 中用一行包括多个文件。可以通过在行中添加 %doc 或 %config 来标记文件。%doc 告诉 RPM 这是一个文档文件，因此如果用户安装软件包时使用 –excludedocs，将不安装该文件。您也可以在 %doc 下不带路径列出文件名，RPM 会在构建目录下查找这些文件并在 RPM 文件中包括它们，并把它们安装到 /usr/share/doc/%{name}-%{version}。以 %doc 的形式包括 README 和 ChangeLog 这样的文件是个好主意。</p><p>%config 告诉 RPM 这是一个配置文件。在升级时，RPM 将会试图避免用 RPM 打包的缺省配置文件覆盖用户仔细修改过的配置。</p><p>注意：如果在 %files 下列出一个目录名，RPM 会包括该目录下的所有文件。通常这不是您想要的，特别对于 /bin 这样的目录。</p><p>eg:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%files</span></span><br><span class="line"><span class="comment">%defattr(-,root,root)      #指定默认权限</span></span><br><span class="line"><span class="comment">%doc NEWS doc/HOWTO README</span></span><br><span class="line"><span class="comment">%dir /etc/default</span></span><br><span class="line"><span class="comment">%attr(0644,root,root)   %config(noreplace) /etc/login.defs</span></span><br><span class="line"><span class="comment">%attr(0600,root,root)   %config /etc/default/useradd</span></span><br><span class="line"><span class="comment">%&#123;_bindir&#125;/sg</span></span><br><span class="line"><span class="comment">%&#123;_bindir&#125;/chage</span></span><br><span class="line"><span class="comment">%attr(0750,root,root)   %&#123;_sbindir&#125;/user*</span></span><br><span class="line"><span class="comment">%attr(0750,root,root)   %&#123;_sbindir&#125;/group*</span></span><br><span class="line"><span class="comment">%&#123;_sbindir&#125;/grpck</span></span><br><span class="line"><span class="comment">%&#123;_sbindir&#125;/pwck</span></span><br><span class="line"><span class="comment">%&#123;_sbindir&#125;/*conv</span></span><br></pre></td></tr></table></figure><h4 id="7）changlog"><a href="#7）changlog" class="headerlink" title="7）changlog"></a>7）changlog</h4><p>主要描述软件的开发记录，它是使用节前缀%changlog表示的。对于包的维护极有好处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%changlog</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="8）example-amp-summer"><a href="#8）example-amp-summer" class="headerlink" title="8）example &amp; summer"></a>8）example &amp; summer</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Summary:    hello world rpm package  </span><br><span class="line">Name:       hello  </span><br><span class="line">Version:    0.1  </span><br><span class="line">Release:    1  </span><br><span class="line"> </span><br><span class="line">License:    GPL</span><br><span class="line">Source:    <span class="comment">%&#123;name&#125;-%&#123;version&#125;.tar.gz</span></span><br><span class="line">Packager:   amoblin  </span><br><span class="line">Group:      Application  </span><br><span class="line">URL:        http://www.ossxp.com    </span><br><span class="line"> </span><br><span class="line"><span class="comment">%description</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%prep  </span></span><br><span class="line"><span class="comment">%setup -q    </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%build  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%install</span></span><br><span class="line">mkdir -p <span class="formula">$RPM_BUILD_ROOT/%&#123;_bindir&#125;</span></span><br><span class="line"><span class="formula">gcc -o hello hello.c</span></span><br><span class="line"><span class="formula">install -c -m 755 hello $</span>RPM_BUILD_ROOT/<span class="comment">%&#123;_bindir&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%files  </span></span><br><span class="line"><span class="comment">%&#123;_bindir&#125;/hello</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%clean</span></span><br><span class="line">rm -rf <span class="formula">$RPM_BUILD_ROOT</span></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">（1）Preamle</span><br><span class="line">Summary：</span><br><span class="line">        用一句话概括该软件包尽量多的信息。</span><br><span class="line">Name：</span><br><span class="line">        软件包的名字，最终RPM软件包是用该名字与版本号，释出号及体系号来命名软件包的。</span><br><span class="line">Version：</span><br><span class="line">        软件版本号。仅当软件包比以前有较大改变时才增加版本号。</span><br><span class="line">Release：</span><br><span class="line">        软件包释出号。一般我们对该软件包做了一些小的补丁的时候就应该把释出号加1。</span><br><span class="line">Vendor：</span><br><span class="line">        软件开发者的名字。</span><br><span class="line">Copyright：</span><br><span class="line">        软件包所采用的版权规则。具体有：GPL（自由软件），BSD，MIT，Public Domain（公共域），               Distributable（贡献），commercial（商业），Share（共享）等，一般的开发都写GPL。</span><br><span class="line">Group： </span><br><span class="line">        软件包所属类别，具体类别在/usr/share/doc/rpm-x.x.x/GROUPS这里可以看到</span><br><span class="line">Source：</span><br><span class="line">        源程序软件包的名字。如 stardict-2.0.tar.gz。</span><br><span class="line"><span class="comment">%description：</span></span><br><span class="line">        软件包详细说明，可写在多个行上。</span><br><span class="line"></span><br><span class="line">（2）<span class="comment">%prep段</span></span><br><span class="line"></span><br><span class="line">这个段是预处理段，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。<span class="comment">%prep和下面的%build，%install段一样，除了可以执行RPM所定义的宏命令（以%开头）以外，还可以执行SHELL命令，命令可以有很多行，如我们常写的tar解包命令。</span></span><br><span class="line"></span><br><span class="line">（3）build段</span><br><span class="line"></span><br><span class="line">本段是建立段，所要执行的命令为生成软件包服务，如make 命令。</span><br><span class="line"></span><br><span class="line">（4）<span class="comment">%install段</span></span><br><span class="line"></span><br><span class="line">本段是安装段，其中的命令在安装软件包时将执行，如make install命令。</span><br><span class="line"></span><br><span class="line">（5）<span class="comment">%files段</span></span><br><span class="line"></span><br><span class="line">本段是文件段，用于定义软件包所包含的文件，分为三类--说明文档（doc），配置文件（config）及执行程序，还可定义文件存取权限，拥有者及组别。</span><br><span class="line"></span><br><span class="line">（6）<span class="comment">%changelog段</span></span><br><span class="line"></span><br><span class="line">本段是修改日志段。你可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。每一个修改日志都有这样一种格式：第一行是：* 星期 月 日 年 修改人 电子信箱。其中：星期、月份均用英文形式的前3个字母，用中文会报错。接下来的行写的是修改了什么地方，可写多行。一般以减号开始，便于后续的查阅。</span><br></pre></td></tr></table></figure><h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h2><p>​   如果想发布rpm格式的源码包或者是二进制包，就要使用rpmbuild工具。</p><p>​   如果我们已经根据本地源码包的成功编译安装而写了spec文件（该文件要以.spec结束），那我们就可以建立一个打包环境，也就是目录树的建立。</p><p>​   一般是在目录下建立5个目录。它门分别是BUILD、SOURCE、SPEC、SRPM、RPM。</p><p>​       - 其中BUILD目录用来存放打包过程中的源文件，</p><p>​       - SOURCE用来存放打包是要用到的源文件和patch，</p><p>​       - SPEC用来存放spec文件，</p><p>​       - SRPM、RPM分别存放打包生成的rpm格式的源文件和二进制文件。</p><p>我们可以根据需要来选用不同的参数打包文件：</p><p>1） 只生成二进制格式的rpm包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -bb xxx.spec</span><br></pre></td></tr></table></figure><p>​   用此命令生成软件包，执行后屏幕将显示执行信息，生成的文件会在刚才建立的RPM目录下存在。</p><p>2）只生成src格式的rpm包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -bs xxx.spec</span><br></pre></td></tr></table></figure><p>​   生成的文件会在刚才建立的SRPM目录下存在。</p><p>3） 只需要生成完整的源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -bp xxx.spec</span><br></pre></td></tr></table></figure><p>​   源文件存在目录BUILD下。读者朋友可能对这个命令不太明白，这个命令的作用就是把tar包解开然后把所有的补丁文件合并而生成一个完整的具最新功能的源文件。</p><p>4） 完全打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -ba xxx.spec</span><br></pre></td></tr></table></figure><p>​   产生以上3个过程分别生成的包。存放在相应的目录下。</p><p>​   软件包制作完成后可用rpm命令查询，看看效果。如果不满意的话可以再次修改软件包描述文件，重新运行以上命令产生新的RPM软件包。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><hr><p><a href="https://www.ibm.com/developerworks/cn/linux/l-rpm/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-rpm/</a></p><p><a href="https://www.zhukun.net/archives/7263" target="_blank" rel="noopener">https://www.zhukun.net/archives/7263</a></p><hr><p>昔我往矣，杨柳依依；今我来思，雨雪霏霏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;RPM全称是 Red Hat Package Manager（Red Hat包管理器）。&lt;/p&gt;
&lt;p&gt;RPM的发布基于
      
    
    </summary>
    
      <category term="linux" scheme="http://wanyaoqi.top/categories/linux/"/>
    
    
      <category term="linux" scheme="http://wanyaoqi.top/tags/linux/"/>
    
      <category term="rpm" scheme="http://wanyaoqi.top/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>python装饰器</title>
    <link href="http://wanyaoqi.top/2017/11/19/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://wanyaoqi.top/2017/11/19/python装饰器/</id>
    <published>2017-11-19T14:46:38.000Z</published>
    <updated>2018-04-06T07:21:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python includes a more natural way of decorating a function by using an annotation on the function that is decorated.<br><a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Decorator_pattern</a><br>译：Python提供了一种更为自然的方式来装饰一个函数，这种方法通过在被装饰的函数前加一个注释来时实现。</p></blockquote><h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a>装饰器原理</h2><p>看一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    func()</span><br><span class="line">        <span class="keyword">print</span> func.__name__, <span class="string">"test wrapper"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"start main"</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="keyword">print</span> main.__name__</span><br></pre></td></tr></table></figure></p><p>得到的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">main test wrapper</span><br><span class="line">wrapper</span><br></pre></td></tr></table></figure></p><p>可以看到装饰器会改变函数的属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> main</span><br><span class="line">&lt;function wrapper at <span class="number">0x7f79c2437938</span>&gt;</span><br></pre></td></tr></table></figure></p><p>此时执行main函数已经被装饰器test返回的wrapper函数给替代了，即 main() == test()()<br>再看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(test_arg)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> test_arg</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"inner_wrapper"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">            <span class="keyword">print</span> func.__name__, <span class="string">"test wrapper"</span></span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><ul><li>这时使用装饰器test必须给参数, 如果不给的话test_arg相当与main函数的地址,</li><li>此时调用wrapper会报错(原因是参数不够)。</li><li>如果去了wrapper函数的参数则inner_wrapper不会被调用</li><li>可以看出带参数的装饰器其实包装了一层外壳，先执行最外层test函数的内容，</li><li>然后将调用的函数的地址传入里层的装饰器</li></ul><p>还有一个问题就是之前代码中的func.<strong>name</strong>和main.<strong>name</strong>的问题，<br>不难看出其实main函数的地址就是wrapper的地址，所以main.<strong>name</strong>打印的是wrapper函数的名字，<br>那么如何获得main函数真正的属性呢？</p><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    func()</span><br><span class="line">        <span class="keyword">print</span> func.__name__, <span class="string">"test wrapper"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>加上functools.wraps装饰器后的打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">main test wrapper</span><br><span class="line">main</span><br></pre></td></tr></table></figure></p><p>进入functools中看warps函数的实现其实可以看到<br>functools.wraps函数将wrapper函数的属性使用setattr设置为传入的func即main函数的属性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Python includes a more natural way of decorating a function by using an annotation on the function that is decorated.&lt;br&gt;&lt;a 
      
    
    </summary>
    
      <category term="python" scheme="http://wanyaoqi.top/categories/python/"/>
    
    
      <category term="python" scheme="http://wanyaoqi.top/tags/python/"/>
    
      <category term="装饰器" scheme="http://wanyaoqi.top/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL deque——part 2</title>
    <link href="http://wanyaoqi.top/2016/08/20/stl_deque_2/"/>
    <id>http://wanyaoqi.top/2016/08/20/stl_deque_2/</id>
    <published>2016-08-20T02:52:35.000Z</published>
    <updated>2018-04-06T07:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接下来介绍一下deque的插入删除操作及其他操作(push, pop …)<br>常见的有push_back, push_front, pop_back, pop_front, insert, erase, clear等<br>包括了内存分配和释放等问题</p></blockquote><h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push pop"></a>push pop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在deque末尾添加元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;   </span><br><span class="line">      <span class="comment">// 当前缓冲区还有空间  </span></span><br><span class="line">      construct(finish.cur, t); <span class="comment">// 直接在可用空间构建  </span></span><br><span class="line">      ++finish.cur; <span class="comment">// 调整finish迭代器  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 当前缓冲区无可用空间（last不能存储元素用）  </span></span><br><span class="line">      push_back_aux(t);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在deque头添加元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;     <span class="comment">// 当前缓冲区还有空间  </span></span><br><span class="line">      construct(start.cur - <span class="number">1</span>, t);   </span><br><span class="line">      --start.cur;        </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前缓冲区无空间可用了  </span></span><br><span class="line">      push_front_aux(t);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删掉末尾元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;<span class="comment">//最后一个缓冲区（finish指的缓冲区）有多于一个元素（含一个）  </span></span><br><span class="line">      --finish.cur;       </span><br><span class="line">      destroy(finish.cur);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      <span class="comment">// 最后一个缓冲区无元素  </span></span><br><span class="line">      pop_back_aux();       <span class="comment">// 这里会进行缓冲区的释放工作  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在deque头删除元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;  </span><br><span class="line">      <span class="comment">// start.node所指缓冲区有多余一个元素（不含一个）  </span></span><br><span class="line">      destroy(start.cur);     </span><br><span class="line">      ++start.cur;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">      <span class="comment">// start.node所指缓冲区只有一个元素  </span></span><br><span class="line">      pop_front_aux();      <span class="comment">// 这里会进行缓冲区释放工作  </span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_back_aux(<span class="keyword">const</span> value_type&amp; t) &#123;  </span><br><span class="line">  value_type t_copy = t;  </span><br><span class="line">  reserve_map_at_back();        <span class="comment">//  若符合某重条件则必须重换一个map  </span></span><br><span class="line">  *(finish.node + <span class="number">1</span>) = allocate_node(); <span class="comment">// 配置一个新结点（缓冲区）  </span></span><br><span class="line">  __STL_TRY &#123;  </span><br><span class="line">    construct(finish.cur, t_copy);      <span class="comment">// 设置值  </span></span><br><span class="line">    finish.set_node(finish.node + <span class="number">1</span>);   <span class="comment">// 改变finish，令其指向新结点  </span></span><br><span class="line">    finish.cur = finish.first;          <span class="comment">// 设置 finish 的状态  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 只有当start.cur == start.first才会调用。  </span></span><br><span class="line"><span class="comment">// 第一个缓冲区没有未用空间时才会调用。和上面实现类似  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_front_aux(<span class="keyword">const</span> value_type&amp; t) &#123;  </span><br><span class="line">  value_type t_copy = t;  </span><br><span class="line">  reserve_map_at_front();         </span><br><span class="line">  *(start.node - <span class="number">1</span>) = allocate_node();    </span><br><span class="line">  __STL_TRY &#123;  </span><br><span class="line">    start.set_node(start.node - <span class="number">1</span>);       </span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;           </span><br><span class="line">    construct(start.cur, t_copy);         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只有当finish.cur == finish.first才会调用  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:pop_back_aux() &#123;  </span><br><span class="line">  deallocate_node(finish.first);      </span><br><span class="line">  finish.set_node(finish.node - <span class="number">1</span>);   </span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;       </span><br><span class="line">  destroy(finish.cur);        </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 只有当start.cur == start.last - 1时才会调用  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:pop_front_aux() &#123;  </span><br><span class="line">  destroy(start.cur);                 </span><br><span class="line">  deallocate_node(start.first);   </span><br><span class="line">  start.set_node(start.node + <span class="number">1</span>);  </span><br><span class="line">  start.cur = start.first;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在map尾添加缓冲区  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>))  </span><br><span class="line">    <span class="comment">//map空间不够用，则开辟新的map空间，把原来map内容拷贝过来。释放原来的  </span></span><br><span class="line">      reallocate_map(nodes_to_add, <span class="literal">false</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在map头添加缓冲区  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)  </span><br><span class="line">      reallocate_map(nodes_to_add, <span class="literal">true</span>);     </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//添加map结点，指向新的缓冲区，add_at_front=true添加在map头，否则添加在尾  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:reallocate_map(size_type nodes_to_add,  </span><br><span class="line">                                              <span class="keyword">bool</span> add_at_front) &#123;  </span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;  </span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;  </span><br><span class="line">  </span><br><span class="line">  map_pointer new_nstart;  </span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;  </span><br><span class="line">    new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span>   </span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)  </span><br><span class="line">      copy(start.node, finish.node + <span class="number">1</span>, new_nstart);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">    size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">// 配置新的结点，准备给map使用  </span></span><br><span class="line">    map_pointer new_map = map_allocator::allocate(new_map_size);  </span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span>  </span><br><span class="line">                         + (add_at_front ? nodes_to_add : <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">// 把原map 內容拷贝  </span></span><br><span class="line">    copy(start.node, finish.node + <span class="number">1</span>, new_nstart);  </span><br><span class="line">    <span class="comment">// 释放放原map  </span></span><br><span class="line">    map_allocator::deallocate(<span class="built_in">map</span>, map_size);  </span><br><span class="line">    <span class="comment">// 设置新map起始位置和大小  </span></span><br><span class="line">    <span class="built_in">map</span> = new_map;  </span><br><span class="line">    map_size = new_map_size;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新设置迭代器 start 和 finish  </span></span><br><span class="line">  start.set_node(new_nstart);  </span><br><span class="line">  finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 在position 处插入一個元素，其值为 x  </span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;      <span class="comment">// position是deque的最前端，则调用push_front()</span></span><br><span class="line">      push_front(x);      </span><br><span class="line">      <span class="keyword">return</span> start;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;   <span class="comment">// position是deque的最末端，则调用push_back()</span></span><br><span class="line">      push_back(x);  </span><br><span class="line">      iterator tmp = finish;  </span><br><span class="line">      --tmp;  </span><br><span class="line">      <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> insert_aux(position, x);       <span class="comment">// 都不是就交给insert_aux 去做  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//在pos处插入一个元素，值为x。要判断插入点距头更近还是尾更近</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator  </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;  </span><br><span class="line">  difference_type index = pos - start;    </span><br><span class="line">  value_type x_copy = x;  </span><br><span class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;    <span class="comment">//插入点之前的元素少</span></span><br><span class="line">    push_front(front());          </span><br><span class="line">    iterator front1 = start;  </span><br><span class="line">    ++front1;  </span><br><span class="line">    iterator front2 = front1;  </span><br><span class="line">    ++front2;  </span><br><span class="line">    pos = start + index;  </span><br><span class="line">    iterator pos1 = pos;  </span><br><span class="line">    ++pos1;  </span><br><span class="line">    copy(front2, pos1, front1);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;                      <span class="comment">//插入点之后的元素少</span></span><br><span class="line">    push_back(back());        </span><br><span class="line">    iterator back1 = finish;  </span><br><span class="line">    --back1;  </span><br><span class="line">    iterator back2 = back1;  </span><br><span class="line">    --back2;  </span><br><span class="line">    pos = start + index;  </span><br><span class="line">    copy_backward(pos, back2, back1);     </span><br><span class="line">  &#125;  </span><br><span class="line">  *pos = x_copy;      </span><br><span class="line">  <span class="keyword">return</span> pos;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整deque的大小。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; len)   <span class="comment">//如果deque变小，直接擦除掉多余的元素</span></span><br><span class="line">      erase(start + new_size, finish);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      insert(finish, new_size - len, x);  <span class="comment">//如果deque变大，则在deque后面插入元素补充</span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; resize(new_size, value_type()); &#125;</span><br></pre></td></tr></table></figure><h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 清除 pos 所指的元素。  </span></span><br><span class="line">  <span class="comment">//判断pos距离头近还是距离尾近，距离那个位置近就移动那个位置的元素，保证移动元素个数最少  </span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;  </span><br><span class="line">    iterator next = pos;  </span><br><span class="line">    ++next;  </span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// pos和deque开头元素的个数  </span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>)) &#123;           <span class="comment">// size() &gt;&gt; 1为size()/2  </span></span><br><span class="line">    <span class="comment">//如果pos距离deque头比较近的话，deque的开头到pos元素向后移  </span></span><br><span class="line">      copy_backward(start, pos, next);    </span><br><span class="line">      pop_front();              <span class="comment">// 移动后，删除第一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;                  <span class="comment">// 否则pos+1到结尾元素向前移，  </span></span><br><span class="line">      copy(next, finish, pos);    </span><br><span class="line">      pop_back();                 </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> start + index;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除两个迭代器之间的元素  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator   </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123; <span class="comment">// 如果是清除整个 deque  </span></span><br><span class="line">    clear();                            <span class="comment">// 直接调用 clear() 即可  </span></span><br><span class="line">    <span class="keyword">return</span> finish;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">    difference_type n = last - first;           <span class="comment">// 擦除区间长度  </span></span><br><span class="line">    difference_type elems_before = first - start;   <span class="comment">// 擦除区间前方元素的个数  </span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;       <span class="comment">// 如果前方的元素少，  </span></span><br><span class="line">      copy_backward(start, first, last);        <span class="comment">// 前方元素向后移（覆盖擦除区间）  </span></span><br><span class="line">      iterator new_start = start + n;           <span class="comment">// deque 的新起点  </span></span><br><span class="line">      destroy(start, new_start);                <span class="comment">// 多于元素析构  </span></span><br><span class="line">      <span class="comment">// 释放多于元素所占内存  </span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)  </span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  </span><br><span class="line">      start = new_start;      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 后方元素更少  </span></span><br><span class="line">      copy(last, finish, first);    <span class="comment">//后方元素向前移动（覆盖擦除区间）     </span></span><br><span class="line">      iterator new_finish = finish - n;   </span><br><span class="line">      destroy(new_finish, finish);        </span><br><span class="line">      <span class="comment">// 释放多于元素所占内存</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)  </span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  </span><br><span class="line">      finish = new_finish;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> start + elems_before;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空deque。最后保留了一个缓冲区，这是deque的策略，也是其初始状态  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:clear() &#123;  </span><br><span class="line">  <span class="comment">//头尾以外的缓冲区，它们肯定是满的。  </span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;  </span><br><span class="line"></span><br><span class="line">    destroy(*node, *node + buffer_size());  </span><br><span class="line">    data_allocator::deallocate(*node, buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123;  <span class="comment">// 至少有2个以上（含）缓冲区  </span></span><br><span class="line">    destroy(start.cur, start.last); <span class="comment">// 头缓冲区元素析构  </span></span><br><span class="line">    destroy(finish.first, finish.cur); <span class="comment">// 尾缓冲区元素析构  </span></span><br><span class="line">    <span class="comment">// 释放尾缓冲区，保留了头缓冲区  </span></span><br><span class="line">    data_allocator::deallocate(finish.first, buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 只有一个缓冲区  </span></span><br><span class="line">    destroy(start.cur, finish.cur); <span class="comment">// 析构，但是不释放  </span></span><br><span class="line">  </span><br><span class="line">  finish = start;   <span class="comment">// 调整迭代器，deque为空  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;接下来介绍一下deque的插入删除操作及其他操作(push, pop …)&lt;br&gt;常见的有push_back, push_front, pop_back, pop_front, insert, erase, clear等&lt;br&gt;包括了内存分配和释放
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="list" scheme="http://wanyaoqi.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>STL deque——part 1</title>
    <link href="http://wanyaoqi.top/2016/08/18/stl_deque_1/"/>
    <id>http://wanyaoqi.top/2016/08/18/stl_deque_1/</id>
    <published>2016-08-18T13:59:56.000Z</published>
    <updated>2016-08-18T14:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h1><p>deque是一个双端队列<br><img src="/imgs/stl_deque/deque_1.png" alt="1"><br><img src="/imgs/stl_deque/deque_2.png" alt="2"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;   </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  ···</span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members  </span></span><br><span class="line">  iterator start;       <span class="comment">// start.cur指向deque的第一个结点  </span></span><br><span class="line">  iterator finish;  <span class="comment">// finish.cur指向迭代器deque的最后一个结点的后一个元素  </span></span><br><span class="line">  </span><br><span class="line">  map_pointer <span class="built_in">map</span>;  <span class="comment">// 指向中控器。其实是指向中控器的第一个结点。  </span></span><br><span class="line">                    <span class="comment">//  中控器是连续的，map_size定义了中控器的大小。  </span></span><br><span class="line">                           </span><br><span class="line">  size_type map_size;   <span class="comment">// 中控器的大小。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="/imgs/stl_deque/deque_3.png" alt="3"></p><h1 id="deque-迭代器"><a href="#deque-迭代器" class="headerlink" title="deque 迭代器"></a>deque 迭代器</h1><p><img src="/imgs/stl_deque/deque_4.png" alt="4"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">此函数用来计算缓冲区的大小 </span></span><br><span class="line"><span class="comment">如果n不等于0，那么返回n，开发者自己决定 </span></span><br><span class="line"><span class="comment">    否则：如果sz小于512，返回512/sz </span></span><br><span class="line"><span class="comment">    如果sz大于512，返回1 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//deque的迭代器，未继承std::iterator  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span>     </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;      iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//没有继承std::iterator，自己定义5个迭代器相应型别。  </span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                 <span class="comment">// (2)  </span></span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;              <span class="comment">// (3)  </span></span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                <span class="comment">// (4)  </span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;    <span class="comment">// (5)  </span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;  <span class="comment">//注意，是指针的指针  </span></span><br><span class="line">  <span class="comment">//map_pointer指向中控器，中控器的存储的是指针，指向node-buf结点缓冲区  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  T* cur;   <span class="comment">// 迭代器所指元素  </span></span><br><span class="line">  T* first; <span class="comment">// 迭代器所指元素所在缓冲区的开头  </span></span><br><span class="line">  T* last;  <span class="comment">// 迭代器所指元素所在缓冲区的结尾（结尾包含在缓冲区内）  </span></span><br><span class="line">  map_pointer node;<span class="comment">//指向中控器的结点，这个结点指向迭代器所指元素所在的缓冲区  </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//迭代器的构造函数  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//x是迭代器所指结点，y为中控器中的结点的值，指向x所指缓冲区  </span></span><br><span class="line">  __deque_iterator(T* x, map_pointer y)   </span><br><span class="line">    : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125;  </span><br><span class="line">    <span class="comment">//默认构造函数  </span></span><br><span class="line">  __deque_iterator() : cur(<span class="number">0</span>), first(<span class="number">0</span>), last(<span class="number">0</span>), node(<span class="number">0</span>) &#123;&#125;  </span><br><span class="line">    <span class="comment">//用一个迭代器x初始化本迭代器  </span></span><br><span class="line">  __deque_iterator(<span class="keyword">const</span> iterator&amp; x)  </span><br><span class="line">    : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器需要重载的运算符  </span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;   </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">两个迭代器之间的距离。这两个迭代器可能不在同一个buffer上。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +  </span><br><span class="line">      (cur - first) + (x.last - x.cur);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    迭代器前进一步。 </span></span><br><span class="line"><span class="comment">    先++cur，再判断cur==last。说明cur不会指向last的。last所指空间不存内容 </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;  </span><br><span class="line">    ++cur;              <span class="comment">// 前进一步  </span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;      <span class="comment">// 到了所在缓冲区的尾端了  </span></span><br><span class="line">      set_node(node + <span class="number">1</span>);   <span class="comment">// 切换到下一个缓冲区  </span></span><br><span class="line">      cur = first;          <span class="comment">//   的第一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   </span><br><span class="line">  &#125;  </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    ++*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//迭代器往回走一步。  </span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123; <span class="comment">// 如果在所在缓冲区的头部  </span></span><br><span class="line">      set_node(node - <span class="number">1</span>);   <span class="comment">// 切换到前一个缓冲区  </span></span><br><span class="line">      cur = last;           <span class="comment">//   的最后一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    --cur;              <span class="comment">// 直接往回走一步  </span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    --*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    迭代器向前进或后退n步（取决于n的正负）。这是支持random access iterator 所必须的操作。 </span></span><br><span class="line"><span class="comment">    如果这个操作不会是迭代器走出当前所在缓冲区，直接更改cur即可。 </span></span><br><span class="line"><span class="comment">    如果这个操作使迭代器走出当前所在缓冲区，要计算出操作后在哪个缓冲区的哪个位置。 </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;  </span><br><span class="line">    difference_type offset = n + (cur - first);  </span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))  </span><br><span class="line">      <span class="comment">// 不会走出当前所在缓冲区  </span></span><br><span class="line">      cur += n;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="comment">// 走出了当前所在缓冲区  </span></span><br><span class="line">      difference_type node_offset =  </span><br><span class="line">        offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())  </span><br><span class="line">                   : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;  </span><br><span class="line">      <span class="comment">// 切换缓冲区  </span></span><br><span class="line">      set_node(node + node_offset);  </span><br><span class="line">      <span class="comment">// 找到切换缓冲区后，迭代器所指向的元素  </span></span><br><span class="line">      cur = first + (offset - node_offset * difference_type(buffer_size()));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="comment">//调用operator+=  </span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">  <span class="comment">// 以上调用了operator*, operator+  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*迭代器关于比较的运算符的重载*/</span>  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//切换缓冲区，更改了first和last，但是未更改cur  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;  </span><br><span class="line">    node = new_node;  </span><br><span class="line">    first = *new_node;  </span><br><span class="line">    last = first + difference_type(buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="/imgs/stl_deque/deque_5.png" alt="5"></p><h1 id="deque的定义"><a href="#deque的定义" class="headerlink" title="deque的定义"></a>deque的定义</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;   </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// 迭代器  </span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;              iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;, BufSiz&gt;  const_iterator;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs  </span></span><br><span class="line">  <span class="comment">// 指向中控器，是指针的指针（pointer of pointer of T）  </span></span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;   </span><br><span class="line">  <span class="comment">// 空间配置器，用来配置缓冲区  </span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;  </span><br><span class="line">  <span class="comment">// 空间配置器，用来配置中控器  </span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_type <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(value_type));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//默认中控器大小为8  </span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members  </span></span><br><span class="line">  iterator start;       <span class="comment">// start.cur指向deque的第一个结点  </span></span><br><span class="line">  iterator finish;  <span class="comment">// finish.cur指向迭代器deque的最后一个结点的后一个元素  </span></span><br><span class="line">  </span><br><span class="line">  map_pointer <span class="built_in">map</span>;  <span class="comment">// 指向中控器。其实是指向中控器的第一个结点。  </span></span><br><span class="line">                    <span class="comment">//  中控器是连续的，map_size定义了中控器的大小。  </span></span><br><span class="line">                           </span><br><span class="line">  size_type map_size;   <span class="comment">// 中控器的大小。  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// 对外的接口  </span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;  </span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;  </span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;  </span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(finish); &#125;  </span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(start); &#125;  </span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> const_reverse_iterator(finish);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> const_reverse_iterator(start);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123;  </span><br><span class="line">    <span class="keyword">return</span> start[difference_type(n)]; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator[]  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> start[difference_type(n)];  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator*  </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//取出最后一个元素  </span></span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    iterator tmp = finish;    </span><br><span class="line">    --tmp;  <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator--  </span></span><br><span class="line">    <span class="keyword">return</span> *tmp;    <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator*  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//返回第一个元素，并不删除  </span></span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *start; &#125;  </span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  </span><br><span class="line">    const_iterator tmp = finish;  </span><br><span class="line">    --tmp;  </span><br><span class="line">    <span class="keyword">return</span> *tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//两分号但是合法</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125;   </span><br><span class="line">    <span class="comment">//deque最大容量。  </span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;  </span><br><span class="line">  <span class="comment">//下面调用了operator::iterator==  </span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//默认构造函数  </span></span><br><span class="line">  <span class="built_in">deque</span>(): start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">    create_map_and_nodes(<span class="number">0</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//用一个deque构建新的deque  </span></span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span>&amp; x)  </span><br><span class="line">    : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">    create_map_and_nodes(x.size());  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      uninitialized_copy(x.begin(), x.end(), start);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//commit or rollback  </span></span><br><span class="line">    __STL_UNWIND(destroy_map_and_nodes());  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//构建大小为n，元素值为value的deque  </span></span><br><span class="line">  <span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">    : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">    : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">    : start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//构建大小为n的deque，默认值为T(),说明deque容器的元素要有默认构造函数  </span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">deque</span><span class="params">(size_type n)</span>  </span></span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value_type());  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;  </span></span><br><span class="line"><span class="class">  <span class="title">deque</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)  </span></span><br><span class="line"><span class="class">    :</span> start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">    range_initialize(first, last, iterator_category(first));  </span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  ~<span class="built_in">deque</span>() &#123;  </span><br><span class="line">    destroy(start, finish);  </span><br><span class="line">    destroy_map_and_nodes();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">deque</span>&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="built_in">deque</span>&amp; x) &#123;  </span><br><span class="line">    <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">    <span class="keyword">if</span> (&amp;x != <span class="keyword">this</span>) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (len &gt;= x.size())  </span><br><span class="line">        erase(copy(x.begin(), x.end(), start), finish);  </span><br><span class="line">      <span class="keyword">else</span> &#123;  </span><br><span class="line">        const_iterator mid = x.begin() + difference_type(len);  </span><br><span class="line">        copy(x.begin(), mid, start);  </span><br><span class="line">        insert(finish, mid, x.end());  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;          </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">deque</span>&amp; x)</span> </span>&#123;  </span><br><span class="line">    __STD::swap(start, x.start);  </span><br><span class="line">    __STD::swap(finish, x.finish);  </span><br><span class="line">    __STD::swap(<span class="built_in">map</span>, x.<span class="built_in">map</span>);  </span><br><span class="line">    __STD::swap(map_size, x.map_size);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deque概述&quot;&gt;&lt;a href=&quot;#deque概述&quot; class=&quot;headerlink&quot; title=&quot;deque概述&quot;&gt;&lt;/a&gt;deque概述&lt;/h1&gt;&lt;p&gt;deque是一个双端队列&lt;br&gt;&lt;img src=&quot;/imgs/stl_deque/deque_1.
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="list" scheme="http://wanyaoqi.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>STL list ——part 2</title>
    <link href="http://wanyaoqi.top/2016/08/18/stl_list_2/"/>
    <id>http://wanyaoqi.top/2016/08/18/stl_list_2/</id>
    <published>2016-08-17T16:31:32.000Z</published>
    <updated>2016-08-17T17:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transfer、splice"><a href="#transfer、splice" class="headerlink" title="transfer、splice"></a>transfer、splice</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将first到last內的所有元素搬移到position 前，不包括last元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (position != last) &#123;  </span><br><span class="line"></span><br><span class="line">    (*(link_type((*last.node).prev))).next = position.node;          </span><br><span class="line">    (*(link_type((*first.node).prev))).next = last.node;       </span><br><span class="line">    (*(link_type((*position.node).prev))).next = first.node; </span><br><span class="line">        </span><br><span class="line">    link_type tmp = link_type((*position.node).prev);        </span><br><span class="line">    (*position.node).prev = (*last.node).prev;                </span><br><span class="line">    (*last.node).prev = (*first.node).prev;                  </span><br><span class="line">    (*first.node).prev = tmp;                            </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迁移过程如图：<br><img src="/imgs/stl_list/transfer.png" alt="transfer"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 x 链表插入到 position 所指位置之前。x 必须不能是 *this。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (!x.empty())   </span><br><span class="line">    transfer(position, x.begin(), x.end());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 將i所指元素插入到 position 所指位置之前。position 和i 可在同一个list。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  iterator j = i;  </span><br><span class="line">  ++j;  </span><br><span class="line">  <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;  </span><br><span class="line">  transfer(position, i, j);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 將 [first,last) 內的所有元素插入到 position 所指位置之前。  </span></span><br><span class="line"><span class="comment">// position 和[first,last)可指在同一个list，  </span></span><br><span class="line"><span class="comment">// 但position不能位于[first,last)之內。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (first != last)   </span><br><span class="line">    transfer(position, first, last);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将x合并到*this上面。两个链表都要先经过递增排序。相当于合并排序的最后一步  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span><br><span class="line">&#123;  </span><br><span class="line">  iterator first1 = begin();  </span><br><span class="line">  iterator last1 = end();  </span><br><span class="line">  iterator first2 = x.begin();  </span><br><span class="line">  iterator last2 = x.end();  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//前提是两个链表都已经递增排序好了  </span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">      iterator next = first2;  </span><br><span class="line">      transfer(first1, first2, ++next);  </span><br><span class="line">      first2 = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      ++first1;  </span><br><span class="line">  <span class="keyword">if</span> (first2 != last2) transfer(last1, first2, last2);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将 list逆置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:reverse() </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//如果链表是空，或者只有一个元素，就不做任何处理  </span></span><br><span class="line">    <span class="comment">//不是用size()==0或size()==1来判断，因为这样比较慢  </span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  ++first;  </span><br><span class="line">  <span class="keyword">while</span> (first != end()) &#123;  </span><br><span class="line">    iterator old = first;  </span><br><span class="line">    ++first;  </span><br><span class="line">    transfer(begin(), old, first);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="list-sort"><a href="#list-sort" class="headerlink" title="list sort"></a>list sort</h1><p>list不能采用STL sort()算法，必须使用自己的sort；因为STL sort只能接收随机流迭代器<br>SGI实现版：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:sort() &#123;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; carry;  </span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fill = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">while</span> (!empty()) </span><br><span class="line">  &#123;  </span><br><span class="line">    carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());  <span class="comment">//取第一个放入carry中</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())     <span class="comment">//counter[i]为空则跳过</span></span><br><span class="line">    &#123;      </span><br><span class="line">      counter[i].merge(carry);                   <span class="comment">//有序的合并到counter</span></span><br><span class="line">      carry.swap(counter[i++]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    carry.swap(counter[i]);           <span class="comment">//将carry中的数据交换到counter[i]中</span></span><br><span class="line">    <span class="keyword">if</span> (i == fill) ++fill;  </span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i)       <span class="comment">//将数组中所有的数据合并到最后一个桶中</span></span><br><span class="line">     counter[i].merge(counter[i<span class="number">-1</span>]);  </span><br><span class="line">  swap(counter[fill<span class="number">-1</span>]);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//两个链表交换，就是他们的node头结点交换 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__STD::swap(node, x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sort的过程是一个循环归并的过程，定义一个tmp和一个list数组</p><pre><code>假设有这样以组数: 3 5 1 2 7 6 9    1.取 3 放入carry中，此时不满足循环条件i==fill，将carry中数据换入counter[0]中，carry为空，counter[0]为{3};2.取 5 放入carry中，carry与counter[0] merge并交换，得到counter为空，counter[1]为{3，5};3.取 1 放如carry中,此时counter[0]为空，不进入while循环，将 1 放入 counter[0]中，counter[0]为{1};4.去 2 放入carry中，和counter[0] merge 后又与counter[1] merge放入counter[2]中，counter[2]为{1，2，3，5}counter[0]和counter[1]为空；</code></pre><p>一直循环下去。。直到list为空。<br>然后最后面for循环将counter中的合并到最后一个中，在换给list，即完成了排序；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;transfer、splice&quot;&gt;&lt;a href=&quot;#transfer、splice&quot; class=&quot;headerlink&quot; title=&quot;transfer、splice&quot;&gt;&lt;/a&gt;transfer、splice&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="list" scheme="http://wanyaoqi.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>STL list ——part 1</title>
    <link href="http://wanyaoqi.top/2016/08/15/stl_list_1/"/>
    <id>http://wanyaoqi.top/2016/08/15/stl_list_1/</id>
    <published>2016-08-15T15:19:53.000Z</published>
    <updated>2016-08-17T11:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a>list结构</h1><p>STL list是一个环形双向链表 ，结点结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prev;<span class="comment">//其实可以设为__list_node&lt;T&gt;*</span></span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>list是一个双向链表,其迭代器可以向前移、向后移,因此迭代器类型为bidirectional_iterator_tag<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有继承 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span>   </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为了支持STL型别标准，自己定义5个类别  </span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;           </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;          </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;             </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;   </span><br><span class="line">  </span><br><span class="line">  link_type node;  <span class="comment">// 指向list的结点指针 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造函数  </span></span><br><span class="line">  __list_iterator(link_type x) : node(x) &#123;&#125;  </span><br><span class="line">  __list_iterator() &#123;&#125;  </span><br><span class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器操作运算符重载</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125; </span><br><span class="line">       </span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;      </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR    </span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span>  </span></span><br><span class="line">      </span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;   </span><br><span class="line">    node = (link_type)((*node).next);     </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;    </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    ++*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;      </span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;   </span><br><span class="line">    node = (link_type)((*node).prev);   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;    </span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;   </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    --*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="list-定义"><a href="#list-定义" class="headerlink" title="list 定义"></a>list 定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt; // 默认为 <span class="title">alloc</span> 为配置器  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span> &#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;    </span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;  </span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;  </span><br><span class="line">  <span class="keyword">typedef</span> list_node* link_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span>  </span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,  </span><br><span class="line">  const_reference, difference_type&gt;  </span><br><span class="line">  const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,  </span><br><span class="line">  difference_type&gt;  </span><br><span class="line">  reverse_iterator;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  <span class="comment">//申请、释放结点 </span></span><br><span class="line">  <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::allocate(); &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::deallocate(p); &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;  </span><br><span class="line">    link_type p = get_node();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      construct(&amp;p-&gt;data, x);    </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(put_node(p));  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;  </span><br><span class="line">    destroy(&amp;p-&gt;data);       </span><br><span class="line">    put_node(p);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="comment">//初始化一个空链表，首尾相连  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    node = get_node();    </span><br><span class="line">    node-&gt;next = node;     </span><br><span class="line">    node-&gt;prev = node;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//初始化长为n的链表，值都为value  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), n, value);      <span class="comment">//先初始化一个空链表在插入n个结点</span></span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line">  <span class="comment">//以迭代器区间初始化一个链表  </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;  </span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">range_initialize</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) &#123;</span>  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  <span class="comment">//</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//commit or rollback  </span></span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* __STL_MEMBER_TEMPLATES */</span>  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:   </span><br><span class="line">  link_type node; <span class="comment">//头结点  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="list元素操作"><a href="#list元素操作" class="headerlink" title="list元素操作"></a>list元素操作</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>list() { empty_initialize(); // 默认构造函数，空链表。//构造长为n的链表list(size_type n, const T&amp; value) { fill_initialize(n, value); } list(int n, const T&amp; value) { fill_initialize(n, value); }  list(long n, const T&amp; value) { fill_initialize(n, value); } explicit list(size_type n) { fill_initialize(n, T()); }//迭代器区间构造list   template &lt;class InputIterator&gt;  list(InputIterator first, InputIterator last){range_initialize(first, last);}//拷贝构造listlist(const list&lt;T, Alloc&gt;&amp; x){range_initialize(x.begin(), x.end());}  </code></pre><h2 id="push、pop、erase、insert、clear、remove、unique"><a href="#push、pop、erase、insert、clear、remove、unique" class="headerlink" title="push、pop、erase、insert、clear、remove、unique"></a>push、pop、erase、insert、clear、remove、unique</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">  insert(begin(), x); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">   insert(end(), x); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">  erase(begin()); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    iterator tmp = end();  </span><br><span class="line">    erase(--tmp);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> <span class="comment">//在postition所指位置之前插入一个结点</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">    link_type tmp = create_node(x); <span class="comment">// 申请一个结点并用x初始化   </span></span><br><span class="line">    tmp-&gt;next = position.node;  </span><br><span class="line">    tmp-&gt;prev = position.node-&gt;prev;  </span><br><span class="line">    <span class="comment">//prev和next指针都是void*，所以需要指针类型转换  </span></span><br><span class="line">    (link_type(position.node-&gt;prev))-&gt;next = tmp;  </span><br><span class="line">    position.node-&gt;prev = tmp;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span>  <span class="comment">//移除position所指结点 </span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">    link_type next_node = link_type(position.node-&gt;next);  </span><br><span class="line">    link_type prev_node = link_type(position.node-&gt;prev);  </span><br><span class="line">    prev_node-&gt;next = next_node;  </span><br><span class="line">    next_node-&gt;prev = prev_node;  </span><br><span class="line">    destroy_node(position.node);  </span><br><span class="line">    <span class="keyword">return</span> iterator(next_node);  </span><br><span class="line">  &#125;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;   </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:clear()    <span class="comment">// 清除所有结点 </span></span><br><span class="line">&#123;  </span><br><span class="line">  link_type cur = (link_type) node-&gt;next; <span class="comment">// begin()  </span></span><br><span class="line">  <span class="keyword">while</span> (cur != node) &#123;   <span class="comment">//遍历结点</span></span><br><span class="line">    link_type tmp = cur;  </span><br><span class="line">    cur = (link_type) cur-&gt;next;  </span><br><span class="line">    destroy_node(tmp);    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 恢复头结点状态</span></span><br><span class="line">  node-&gt;next = node;  </span><br><span class="line">  node-&gt;prev = node;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class="keyword">const</span> T&amp; value) <span class="comment">// 将数值为value的结点移除</span></span><br><span class="line">&#123;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  iterator last = end();  </span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;    </span><br><span class="line">    iterator next = first;  </span><br><span class="line">    ++next;  </span><br><span class="line">    <span class="keyword">if</span> (*first == value) erase(first);  <span class="comment">// 移除  </span></span><br><span class="line">    first = next;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:unique()<span class="comment">// 移除数值相同的连续元素 ，只有相同的连续元素才会被移除！！</span></span><br><span class="line">&#123;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  iterator last = end();  </span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;  </span><br><span class="line">  iterator next = first;  </span><br><span class="line">  <span class="keyword">while</span> (++next != last) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (*first == *next)</span><br><span class="line">      erase(next);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      first = next;  </span><br><span class="line">    next = first;    <span class="comment">//调整范围</span></span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    size_type result = <span class="number">0</span>;  </span><br><span class="line">    distance(begin(), end(), result);  <span class="comment">// 在&lt;stl_iterator.h&gt;定义，result是引用传递  </span></span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list结构&quot;&gt;&lt;a href=&quot;#list结构&quot; class=&quot;headerlink&quot; title=&quot;list结构&quot;&gt;&lt;/a&gt;list结构&lt;/h1&gt;&lt;p&gt;STL list是一个环形双向链表 ，结点结构如下：&lt;br&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="list" scheme="http://wanyaoqi.top/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>STL vector</title>
    <link href="http://wanyaoqi.top/2016/08/14/stl_vector/"/>
    <id>http://wanyaoqi.top/2016/08/14/stl_vector/</id>
    <published>2016-08-13T17:53:03.000Z</published>
    <updated>2016-08-13T18:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h1><p>   vector 数据安排上和数组非常相似，差别在于数组大小定义后不能在改变而vector内部会自行扩充空间容纳新元素</p><h1 id="vector-定义"><a href="#vector-定义" class="headerlink" title="vector 定义"></a>vector 定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>, <span class="title">class</span> _<span class="title">A</span> = <span class="title">allocator</span>&lt;_Ty&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;_Ty, _A&gt;     _Myt;</span><br><span class="line"><span class="keyword">typedef</span> _A                  allocator_type;</span><br><span class="line"><span class="keyword">typedef</span> _A::size_type       size_type;</span><br><span class="line"><span class="keyword">typedef</span> _A::difference_type difference_type;</span><br><span class="line"><span class="keyword">typedef</span> _A::pointer         _Tptr;</span><br><span class="line"><span class="keyword">typedef</span> _A::const_pointer   _Ctptr;</span><br><span class="line"><span class="keyword">typedef</span> _A::reference       reference;</span><br><span class="line"><span class="keyword">typedef</span> _A::const_reference const_reference;</span><br><span class="line"><span class="keyword">typedef</span> _A::value_type      value_type;</span><br><span class="line"><span class="keyword">typedef</span> _Tptr               iterator;                <span class="comment">//vector迭代器就是本身的指针</span></span><br><span class="line"><span class="keyword">typedef</span> _Ctptr              const_iterator;</span><br><span class="line"></span><br><span class="line">protect:</span><br><span class="line">_A allocator;                <span class="comment">//空间配置器</span></span><br><span class="line">iterator _First, _Last, _End;<span class="comment">//正在使用的头，正在使用的尾，空间的尾</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">explicit vector(const _A&amp; _Al = _A())                 //简单的初始化成员变量</span><br><span class="line">: allocator(_Al), _First(<span class="number">0</span>), _Last(<span class="number">0</span>), _End(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">explicit vector(size_type _N, const _Ty&amp; _V = _Ty(),  //初始化_N个_TY变量</span><br><span class="line"><span class="keyword">const</span> _A&amp; _Al = _A())</span><br><span class="line">: allocator(_Al)</span><br><span class="line">&#123;_First = allocator.allocate(_N, (<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">_Ufill(_First, _N, _V);                       <span class="comment">//这个函数后面会有，就是从_F开始构造_N个_V                   </span></span><br><span class="line">_Last = _First + _N;</span><br><span class="line">_End = _Last; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> _Myt&amp; _X)                           <span class="comment">//拷贝构造函数</span></span><br><span class="line">: allocator(_X.allocator)</span><br><span class="line">&#123;_First = allocator.allocate(_X.size(), (<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">_Last = _Ucopy(_X.begin(), _X.end(), _First);</span><br><span class="line">_End = _Last; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> const_iterator _It;</span><br><span class="line"><span class="built_in">vector</span>(_It _F, _It _L, <span class="keyword">const</span> _A&amp; _Al = _A())     <span class="comment">//构造vector并在开始位置插入_F到_L间的数据</span></span><br><span class="line">: allocator(_Al), _First(<span class="number">0</span>), _Last(<span class="number">0</span>), _End(<span class="number">0</span>)</span><br><span class="line">&#123;insert(begin(), _F, _L); &#125;</span><br></pre></td></tr></table></figure><h1 id="vector-元素操作"><a href="#vector-元素操作" class="headerlink" title="vector 元素操作"></a>vector 元素操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void resize(size_type _N, const _Ty&amp; _X = _Ty())  //resize手动改变vector容量</span><br><span class="line">&#123;<span class="keyword">if</span> (size() &lt; _N)</span><br><span class="line">insert(end(), _N - size(), _X);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_N &lt; size())</span><br><span class="line">erase(begin() + _N, end()); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//已用大小</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> (_First == <span class="number">0</span> ? <span class="number">0</span> : _Last - _First); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> (size() == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type _P)</span><br><span class="line">&#123;<span class="keyword">return</span> (*(begin() + _P)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> _Ty&amp; _X)</span>     <span class="comment">//在容器的最后插入一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;insert(end(), _X); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span>                   <span class="comment">//删除最后一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;erase(end() - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">iterator insert(iterator _P, const _Ty&amp; _X = _Ty()) //插入一个,返回的迭代器指向的是</span><br><span class="line">&#123;size_type _O = _P - begin();</span><br><span class="line">insert(_P, <span class="number">1</span>, _X);</span><br><span class="line"><span class="keyword">return</span> (begin() + _O); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator _P, size_type _M, <span class="keyword">const</span> _Ty&amp; _X)</span> <span class="comment">//从_P开始插入_M个_X元素</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">if</span> (_End - _Last &lt; _M)</span><br><span class="line">&#123;size_type _N = size() + (_M &lt; size() ? size() : _M);</span><br><span class="line">iterator _S = allocator.allocate(_N, (<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">iterator _Q = _Ucopy(_First, _P, _S);</span><br><span class="line">_Ufill(_Q, _M, _X);</span><br><span class="line">_Ucopy(_P, _Last, _Q + _M);</span><br><span class="line">_Destroy(_First, _Last);</span><br><span class="line">allocator.deallocate(_First, _End - _First);</span><br><span class="line">_End = _S + _N;</span><br><span class="line">_Last = _S + size() + _M;</span><br><span class="line">_First = _S; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_Last - _P &lt; _M)</span><br><span class="line">&#123;_Ucopy(_P, _Last, _P + _M);</span><br><span class="line">_Ufill(_Last, _M - (_Last - _P), _X);</span><br><span class="line">fill(_P, _Last, _X);</span><br><span class="line">_Last += _M; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; _M)</span><br><span class="line">&#123;_Ucopy(_Last - _M, _Last, _Last);</span><br><span class="line">copy_backward(_P, _Last - _M, _Last);</span><br><span class="line">fill(_P, _P + _M, _X);</span><br><span class="line">_Last += _M; &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator _P, _It _F, _It _L)</span></span></span><br><span class="line"><span class="function"></span>&#123;size_type _M = <span class="number">0</span>;</span><br><span class="line">_Distance(_F, _L, _M);</span><br><span class="line"><span class="keyword">if</span> (_End - _Last &lt; _M)</span><br><span class="line">&#123;size_type _N = size() + (_M &lt; size() ? size() : _M);</span><br><span class="line">iterator _S = allocator.allocate(_N, (<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">iterator _Q = _Ucopy(_First, _P, _S);</span><br><span class="line">_Q = _Ucopy(_F, _L, _Q);</span><br><span class="line">_Ucopy(_P, _Last, _Q);</span><br><span class="line">_Destroy(_First, _Last);</span><br><span class="line">allocator.deallocate(_First, _End - _First);</span><br><span class="line">_End = _S + _N;</span><br><span class="line">_Last = _S + size() + _M;</span><br><span class="line">_First = _S; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_Last - _P &lt; _M)</span><br><span class="line">&#123;_Ucopy(_P, _Last, _P + _M);</span><br><span class="line">_Ucopy(_F + (_Last - _P), _L, _Last);</span><br><span class="line">copy(_F, _F + (_Last - _P), _P);</span><br><span class="line">_Last += _M; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; _M)</span><br><span class="line">&#123;_Ucopy(_Last - _M, _Last, _Last);</span><br><span class="line">copy_backward(_P, _Last - _M, _Last);</span><br><span class="line">copy(_F, _L, _P);</span><br><span class="line">_Last += _M; &#125;&#125;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator _P)</span></span></span><br><span class="line"><span class="function"></span>&#123;copy(_P + <span class="number">1</span>, end(), _P);    <span class="comment">// 从—_p+1开始往前挪</span></span><br><span class="line">_Destroy(_Last - <span class="number">1</span>, _Last);</span><br><span class="line">--_Last;</span><br><span class="line"><span class="keyword">return</span> (_P); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator _F, iterator _L)</span></span></span><br><span class="line"><span class="function"></span>&#123;iterator _S = copy(_L, end(), _F);</span><br><span class="line">_Destroy(_S, end());</span><br><span class="line">_Last = _S;</span><br><span class="line"><span class="keyword">return</span> (_F); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;erase(begin(), end()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">void</span> _Destroy(iterator _F, iterator _L)</span><br><span class="line">&#123;<span class="keyword">for</span> (; _F != _L; ++_F)</span><br><span class="line">allocator.destroy(_F); &#125;</span><br><span class="line">iterator _Ucopy(const_iterator _F, const_iterator _L,</span><br><span class="line">iterator _P)</span><br><span class="line">&#123;<span class="keyword">for</span> (; _F != _L; ++_P, ++_F)</span><br><span class="line">allocator.construct(_P, *_F);</span><br><span class="line"><span class="keyword">return</span> (_P); &#125;</span><br><span class="line"><span class="keyword">void</span> _Ufill(iterator _F, size_type _N, <span class="keyword">const</span> _Ty &amp;_X)</span><br><span class="line">&#123;<span class="keyword">for</span> (; <span class="number">0</span> &lt; _N; --_N, ++_F)</span><br><span class="line">allocator.construct(_F, _X); &#125;</span><br><span class="line"><span class="keyword">void</span> _Xran() <span class="keyword">const</span></span><br><span class="line">&#123;_THROW(out_of_range, <span class="string">"invalid vector&lt;T&gt; subscript"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//容量</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> (_First == <span class="number">0</span> ? <span class="number">0</span> : _End - _First); &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vector概述&quot;&gt;&lt;a href=&quot;#vector概述&quot; class=&quot;headerlink&quot; title=&quot;vector概述&quot;&gt;&lt;/a&gt;vector概述&lt;/h1&gt;&lt;p&gt;   vector 数据安排上和数组非常相似，差别在于数组大小定义后不能在改变而vector
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="vector" scheme="http://wanyaoqi.top/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>STL  traits</title>
    <link href="http://wanyaoqi.top/2016/08/10/stl_traits/"/>
    <id>http://wanyaoqi.top/2016/08/10/stl_traits/</id>
    <published>2016-08-10T04:56:46.000Z</published>
    <updated>2016-08-16T03:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL-traits的实现"><a href="#STL-traits的实现" class="headerlink" title="STL traits的实现"></a>STL traits的实现</h1><pre><code>traits 是一种能获取出你所需类型特性的方法：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span><span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Cat</span>,<span class="title">class</span> _<span class="title">T</span>,<span class="title">class</span> _<span class="title">Dis</span> = <span class="title">int</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span> _<span class="title">P</span> = _<span class="title">T</span>*, <span class="title">class</span> _<span class="title">Ref</span> = _<span class="title">T</span>&amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Cat iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> _T   value_type;</span><br><span class="line"><span class="keyword">typedef</span> _Dis difference_type;</span><br><span class="line"><span class="keyword">typedef</span> _P   pointer;</span><br><span class="line"><span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T         value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>       difference_type;</span><br><span class="line"><span class="keyword">typedef</span> T *       pointer;</span><br><span class="line"><span class="keyword">typedef</span> T &amp;       reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T               value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>             difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> T *       pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> T &amp;       reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:iterator_category</span><br><span class="line">iterator_category(Iterator &amp;)      <span class="comment">//迭代器的'类型'</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">return</span> iterator_category();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:value_type*</span><br><span class="line">value_type(Iterator &amp;)                       <span class="comment">//迭代器所指之物类型</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:difference_type *</span><br><span class="line">difference_type(Iterator &amp;)                 <span class="comment">//获取差值类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h1><p><img src="/imgs/Summary/stl_iterator.png" alt="stl_iterator"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span><span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="advance例子"><a href="#advance例子" class="headerlink" title="advance例子"></a>advance例子</h1><p><img src="/imgs/Summary/stl_traits.png" alt="stl_traits"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL-traits的实现&quot;&gt;&lt;a href=&quot;#STL-traits的实现&quot; class=&quot;headerlink&quot; title=&quot;STL traits的实现&quot;&gt;&lt;/a&gt;STL traits的实现&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;traits 是一种能获取出你所需类
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="traits" scheme="http://wanyaoqi.top/tags/traits/"/>
    
  </entry>
  
  <entry>
    <title>可变参函数</title>
    <link href="http://wanyaoqi.top/2016/08/06/stdarg/"/>
    <id>http://wanyaoqi.top/2016/08/06/stdarg/</id>
    <published>2016-08-06T06:33:58.000Z</published>
    <updated>2016-08-07T12:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p><img src="/imgs/Summary/stdargs.png" alt="stdargs"></p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h2><pre><code>va_list 是一个字符指针类型。typedef char *va_list; </code></pre><h2 id="va-start"><a href="#va-start" class="headerlink" title="va_start"></a>va_start</h2><p>va_start用于初始化 va_list, 取第一个参数(从左向右)的地址再向高地址偏移LASTARG大小，实际上指向了第二个参数(从左向右)</p><pre><code>#ifndef __sparc__#define va_start(AP, LASTARG) \(AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG))) //AP即va_list#else#define va_start(AP, LASTARG) \(__builtin_saveregs (), \AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))#endif__builtin_saveregs()是在gcc 的库程序libgcc2.c 中定义的，用于保存寄存器。它的说明可参见gcc 手册章节“Target Description Macros”中的“Implementing the Varargs Macros”小节。</code></pre><h3 id="va-rounded-size"><a href="#va-rounded-size" class="headerlink" title="__va_rounded_size"></a>__va_rounded_size</h3><p>__va_rounded_size定义了取整后的TYPE 类型的字节长度值。是int 长度(4)的倍数。</p><pre><code>#define __va_rounded_size(TYPE) \(((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</code></pre><h2 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg"></a>va_arg</h2><p>va_arg先让AP偏移到指向下一个参数的位置，再返回要取的参数</p><pre><code>#define va_arg(AP, TYPE) \(AP += __va_rounded_size (TYPE), \*((TYPE *) (AP - __va_rounded_size (TYPE))))</code></pre><h2 id="va-end"><a href="#va-end" class="headerlink" title="va_end"></a>va_end</h2><p>va_end 必须在va_arg 读完所有的参数后再被调用。<br>va_end 可以修改AP 使其在重新调用va_start 之前不能被使用(把va_list指向NULL)。<br>    void va_end (va_list);    // 在gnulib 中定义</p><pre><code>#define va_end(AP)</code></pre><h1 id="Linux内核代码Acenv-h中也定义了一组宏"><a href="#Linux内核代码Acenv-h中也定义了一组宏" class="headerlink" title="Linux内核代码Acenv.h中也定义了一组宏"></a>Linux内核代码Acenv.h中也定义了一组宏</h1><p><img src="/imgs/Summary/linux_args.png" alt="linuxstdargs"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用示例&quot;&gt;&lt;a href=&quot;#使用示例&quot; class=&quot;headerlink&quot; title=&quot;使用示例&quot;&gt;&lt;/a&gt;使用示例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/imgs/Summary/stdargs.png&quot; alt=&quot;stdargs&quot;&gt;&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="stdargs" scheme="http://wanyaoqi.top/tags/stdargs/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="http://wanyaoqi.top/2016/06/23/lcs/"/>
    <id>http://wanyaoqi.top/2016/06/23/lcs/</id>
    <published>2016-06-23T04:18:38.000Z</published>
    <updated>2016-08-05T04:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长公共子序列（LongestCommonSubsequence）"><a href="#最长公共子序列（LongestCommonSubsequence）" class="headerlink" title="最长公共子序列（LongestCommonSubsequence）"></a>最长公共子序列（LongestCommonSubsequence）</h1><p>一个数列S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S称为已知序列的最长公共子序列。<br>最长公共子序列问题可以由动态规划求解</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。<br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化（en:memoization）存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。————<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">维基百科</a></p><h1 id="动态规划求解LCS"><a href="#动态规划求解LCS" class="headerlink" title="动态规划求解LCS"></a>动态规划求解LCS</h1><h3 id="1-最优子结构性质"><a href="#1-最优子结构性质" class="headerlink" title="1.最优子结构性质"></a>1.最优子结构性质</h3><p>设输入序列是X [0 .. m-1] 和 Y [0 .. n-1]，长度分别为 m 和 n。和设序列 L(X [0 .. m-1]，Y[0 .. n-1]) 是这两个序列的 LCS 的长度，以下为 L(X [0 .. M-1]，Y [0 .. N-1]) 的递归定义：</p><pre><code>1）如果两个序列的最后一个元素匹配（即X [M-1] == Y [N-1]）</code></pre><p>　　 则：L（X [0 .. M-1]，Y [0 .. N-1]）= 1 + L（X [0 .. M-2]，Y [0 .. N-1]）</p><pre><code>2）如果两个序列的最后字符不匹配（即X [M-1] != Y [N-1]）</code></pre><p>　　 则：L(X [0 .. M-1]，Y [0 .. N-1]) = MAX(L(X [0 .. M-2]，Y [0 .. N-1])，L(X [0 .. M-1]，Y [0 .. N-2]))</p><h3 id="2-重叠子问题"><a href="#2-重叠子问题" class="headerlink" title="2.重叠子问题"></a>2.重叠子问题</h3><pre><code>很明显，LCS 很多子问题也都共享子子问题，因此可以对其进行递归求解。具体的算法时间度为 O(m*n)，可以优化至 O(m+n)。</code></pre><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><p>代码如下：</p><h3 id="未优化"><a href="#未优化" class="headerlink" title="未优化"></a>未优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Longest_Common_Subsequence(char *sa, int n1, char *sb, int n2)</span><br><span class="line">&#123;</span><br><span class="line">if (n1 &gt; 0 &amp;&amp; n2 &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">if (sa[n1 - 1] == sb[n2 - 1]) </span><br><span class="line">return 1 + Longest_Common_Subsequence(sa, n1 - 1, sb, n2 - 1);</span><br><span class="line">else </span><br><span class="line">return max(Longest_Common_Subsequence(sa, n1 , sb, n2 - 1),</span><br><span class="line">Longest_Common_Subsequence(sa, n1 - 1, sb, n2 ));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int lcs(char *sa, int n1, char *sb, int n2)</span><br><span class="line">&#123;</span><br><span class="line">int **ls = new int*[n1];</span><br><span class="line">for (int i = 0; i &lt; n1; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ls[i] = new int[n2];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n1; ++i)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; n2; ++j)</span><br><span class="line">&#123;</span><br><span class="line">if (i == 0 || j == 0) ls[i][j] = 0;</span><br><span class="line">else if (sa[i - 1] == sb[j - 1]) ls[i][j] = ls[i - 1][j - 1] + 1;</span><br><span class="line">else ls[i][j] = max(ls[i - 1][j], ls[i][j - 1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int tmp = ls[n1 - 1][n2 - 1];</span><br><span class="line">for (int k = 0; k &lt; n1; ++k)</span><br><span class="line">&#123;</span><br><span class="line">delete []ls[k];</span><br><span class="line">&#125;</span><br><span class="line">delete []ls;</span><br><span class="line">return tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长公共子序列（LongestCommonSubsequence）&quot;&gt;&lt;a href=&quot;#最长公共子序列（LongestCommonSubsequence）&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列（LongestCommonSubse
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://wanyaoqi.top/categories/Algorithm/"/>
    
    
      <category term="LongestCommonSubsequence" scheme="http://wanyaoqi.top/tags/LongestCommonSubsequence/"/>
    
      <category term="Dynamic_Programming" scheme="http://wanyaoqi.top/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>C++11</title>
    <link href="http://wanyaoqi.top/2016/06/20/C++11/"/>
    <id>http://wanyaoqi.top/2016/06/20/C++11/</id>
    <published>2016-06-19T17:14:38.000Z</published>
    <updated>2016-07-23T17:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>auto是C++程序设计语言的关键字。自C++11以来，auto关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。–维基百科<br>auto实际上实在编译时对变量进行了类型推导，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。<br>从汇编看也是如此：<br><img src="/imgs/Summary/int.png" alt="int"><br><img src="/imgs/Summary/auto_int.png" alt="auto_int"><br>自定义类型<br><img src="/imgs/Summary/A.png" alt="A"><br><img src="/imgs/Summary/auto_A.png" alt="auto_A"><br>auto用于模板简化了模板的操作<br><img src="/imgs/Summary/auto_template.png" alt="auto_template"></p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>它可以用于创建并定义匿名的函数对象形式如下：<br>[函数对象参数]（操作符重载函数参数） -&gt;返回值类型{函数体}(具体参数)<br><img src="/imgs/Summary/lambda.png" alt="lambda"></p><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>decltype的功能与auto相反，从变量得到类型<br><img src="/imgs/Summary/decltype.png" alt="decltype"></p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>右值引用（rvalue reference），是C++程序设计语言自C++11标准提出的一类数据类型。用于实现移动语义（move semantic）与完美转发（perfect forwarding）。–维基百科<br>在资源转移不是调用拷贝等操作而是实现了资源的转移<br><a href="https://www.zhihu.com/question/22111546" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;auto&quot;&gt;&lt;a href=&quot;#auto&quot; class=&quot;headerlink&quot; title=&quot;auto&quot;&gt;&lt;/a&gt;auto&lt;/h1&gt;&lt;p&gt;auto是C++程序设计语言的关键字。自C++11以来，auto关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="C++11" scheme="http://wanyaoqi.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>STL空间配置器</title>
    <link href="http://wanyaoqi.top/2016/06/12/stl_alloc/"/>
    <id>http://wanyaoqi.top/2016/06/12/stl_alloc/</id>
    <published>2016-06-11T17:26:33.000Z</published>
    <updated>2016-08-12T07:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h1><p>当所申请的空间大于128bytes时，stl直接使用一级空间配置器<br>一级空间配置器其实是对malloc的封装，以及添加了类似new_handler处理内存分配不足的情况<br>当内存不足时调用oom_malloc尝试回收一些已分配的内存，调用的是__malloc_alloc_oom_handler方法(如果有的话，没有就抛出异常)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span><span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> (*my_malloc_handler) () = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">void</span> *result = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)<span class="comment">//不断的去尝试</span></span><br><span class="line">&#123;</span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == my_malloc_handler)</span><br><span class="line">&#123;</span><br><span class="line">__THROW_BAD_ALLOC;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">(*my_malloc_handler)();<span class="comment">//调用malloc_handler</span></span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">malloc</span>(n);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> (*my_malloc_handler) () = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">void</span> *result = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == my_malloc_handler)</span><br><span class="line">&#123;</span><br><span class="line">__THROW_BAD_ALLOC;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">(*my_malloc_handler)();</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">realloc</span>(p,n);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> * result = <span class="built_in">malloc</span>(n);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == result)</span><br><span class="line">&#123;</span><br><span class="line">result = oom_malloc(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span><span class="comment">/*n*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> <span class="comment">/*old_sz*/</span>,<span class="keyword">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> result = <span class="built_in">realloc</span>(p,new_sz);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == result)</span><br><span class="line">&#123;</span><br><span class="line">result = oom_realloc(p,new_sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set_new_handler ;</span></span><br><span class="line">static void(*set_malloc_handler(void (*f)()))() //参数和返回值全是函数指针</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> (*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">__malloc_alloc_oom_handler = f;</span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> (*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)()= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></p><h1 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h1><p>二级空间配置器其实是一个内存池，他维持这一个空闲链表数组，所需字节数全上调成8的倍数，然后在空闲链表里面找。<br>当空闲链表内存块不足时，优先从已申请好的空闲堆内存中填充空闲链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>&#123;__ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span>&#123;__MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line"><span class="keyword">enum</span>&#123;__NFREELIST = __MAX_BYTES/__ALIGN&#125;;</span><br><span class="line"><span class="keyword">union</span> obj                                    <span class="comment">//链表的结构，空间的有效利用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">union</span> obj *free_list_link;</span><br><span class="line"><span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> obj * <span class="keyword">volatile</span> free_list[__NFREELIST];<span class="comment">//空闲链表数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bytes + __ALIGN <span class="number">-1</span>) / __ALIGN <span class="number">-1</span>;<span class="comment">//寻找在数组中的下标位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bytes + __ALIGN <span class="number">-1</span>) &amp; ~(__ALIGN<span class="number">-1</span>);<span class="comment">//上调成8的倍数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * start_free; <span class="comment">//空闲内存起始地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * end_free;   <span class="comment">//空闲内存结束地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;  <span class="comment">//空闲堆内存大小</span></span><br></pre></td></tr></table></figure></p><h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><p>如果找到了则把那块空间从free_list中非配给用户，没找到则调用refill()填充free_list<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span><span class="comment">// 15</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj * <span class="keyword">volatile</span> * my_free_list = <span class="literal">NULL</span>;</span><br><span class="line">obj *result = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> malloc_alloc::allocate(n);</span><br><span class="line">&#125;</span><br><span class="line">my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">result = *my_free_list;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == result)       <span class="comment">//如果free_list为空则调用refill填充或直接分配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *r = refill(ROUND_UP(n));</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">*my_free_list = result-&gt;free_list_link;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="refill"><a href="#refill" class="headerlink" title="refill"></a>refill</h2><p>STL规定refill为内存不足的那块填充20块相应大小的内存块，但是可能出现内存不足的情况所有申请到的不一定是20个内存快(可能只有1个)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="comment">//</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> *chunk = chunk_alloc(n,nobjs);<span class="comment">// 申请内存块</span></span><br><span class="line">obj *<span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">obj *result;</span><br><span class="line">obj *current_obj, *next_obj;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>==nobjs) <span class="keyword">return</span> chunk;</span><br><span class="line">my_free_list=free_list + FREELIST_INDEX(n);</span><br><span class="line">result=(obj *)chunk;</span><br><span class="line">*my_free_list=next_obj=(obj *)(chunk+n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;;i++)                    <span class="comment">//将剩余的块连接到空闲链表</span></span><br><span class="line">&#123;</span><br><span class="line">current_obj = next_obj;</span><br><span class="line">next_obj=(obj *)((<span class="keyword">char</span> *)next_obj + n);</span><br><span class="line"><span class="keyword">if</span>(nobjs <span class="number">-1</span>==i)</span><br><span class="line">&#123;</span><br><span class="line">current_obj-&gt;free_list_link=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">current_obj-&gt;free_list_link=next_obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;                <span class="comment">//将第一个内存块返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="chunk-alloc"><a href="#chunk-alloc" class="headerlink" title="chunk_alloc"></a>chunk_alloc</h2><p>chunk_alloc函数分配内存块给free_list,他和refill是维持这个结构的核心。处理了多种内存不足的情况<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> * <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size,<span class="keyword">int</span> &amp;nobjs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *result = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_bytes = size*nobjs;</span><br><span class="line"><span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"><span class="keyword">if</span>(bytes_left &gt;= total_bytes)<span class="comment">//当剩余内存完全足够</span></span><br><span class="line">&#123;</span><br><span class="line">result = start_free;</span><br><span class="line">start_free += total_bytes;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size)<span class="comment">//内存不够分配20块但能分配一块或一块以上</span></span><br><span class="line">&#123;</span><br><span class="line">nobjs = bytes_left/size;</span><br><span class="line">total_bytes = size*nobjs;</span><br><span class="line">result = start_free;</span><br><span class="line">start_free += total_bytes;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="comment">//剩余内存一块都不能分配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> bytes_to_get=<span class="number">2</span> *total_bytes+ROUND_UP(heap_size&gt;&gt;<span class="number">4</span>);</span><br><span class="line"><span class="comment">//先给剩余的内存找到合适的free list(先处理start_free——end_free的那段内存)</span></span><br><span class="line"><span class="keyword">if</span>(bytes_left&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">obj * <span class="keyword">volatile</span> *my_free_list=free_list +FREELIST_INDEX(bytes_left);</span><br><span class="line">((obj *)start_free)-&gt;free_list_link= *my_free_list;</span><br><span class="line">*my_free_list=(obj *)start_free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向堆空间申请内存</span></span><br><span class="line">start_free=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>==start_free)<span class="comment">//堆空间不足时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">obj *<span class="keyword">volatile</span>* my_free_list,*p;</span><br><span class="line"><span class="comment">//遍历比他大的free list查看是否还剩有未使用内存</span></span><br><span class="line"><span class="keyword">for</span>(i=size;i&lt;__MAX_BYTES;i+=__ALIGN)</span><br><span class="line">&#123;</span><br><span class="line">my_free_list = free_list +FREELIST_INDEX(i);</span><br><span class="line">p = *my_free_list;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>!=p)<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">*my_free_list = p -&gt;free_list_link;</span><br><span class="line">start _free = (<span class="keyword">char</span> *)p;</span><br><span class="line">end_free = (<span class="keyword">char</span> *)p;</span><br><span class="line"><span class="comment">//由于nobjs 传的是引用所以递归调用修正nobjs</span></span><br><span class="line"><span class="keyword">return</span> (chunk_alloc(size,nobjs));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end_free=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用一级空间配置器,看看malloc_handler能否挤出内存...</span></span><br><span class="line">start_free =(<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">&#125;</span><br><span class="line">heap_size +=bytes_to_get;</span><br><span class="line">end_free =start_free +bytes_to_get;</span><br><span class="line"><span class="keyword">return</span> (chunk_alloc(size,nobjs));<span class="comment">//同上</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj * <span class="keyword">volatile</span> * my_free_list = <span class="literal">NULL</span>;</span><br><span class="line">obj *q = (obj*)p;</span><br><span class="line"><span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line">malloc_alloc::deallocate(p,n);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">q-&gt;free_list_link = *my_free_list;</span><br><span class="line">*my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p>如图：<br><img src="/imgs/Summary/stl_alloc.png" alt="二级空间配置器内存结构"><br>参考资料——STL源码剖析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一级空间配置器&quot;&gt;&lt;a href=&quot;#一级空间配置器&quot; class=&quot;headerlink&quot; title=&quot;一级空间配置器&quot;&gt;&lt;/a&gt;一级空间配置器&lt;/h1&gt;&lt;p&gt;当所申请的空间大于128bytes时，stl直接使用一级空间配置器&lt;br&gt;一级空间配置器其实是对ma
      
    
    </summary>
    
      <category term="Summary" scheme="http://wanyaoqi.top/categories/Summary/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
      <category term="STL" scheme="http://wanyaoqi.top/tags/STL/"/>
    
      <category term="alloc" scheme="http://wanyaoqi.top/tags/alloc/"/>
    
  </entry>
  
  <entry>
    <title>海量数据中求最大的K个数</title>
    <link href="http://wanyaoqi.top/2016/06/06/heap_sort/"/>
    <id>http://wanyaoqi.top/2016/06/06/heap_sort/</id>
    <published>2016-06-06T04:18:38.000Z</published>
    <updated>2016-06-06T04:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在n个数中求最大的K个数</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>建立一个K个节点的小根堆，再遍历n个数<br>与小根堆的第一个元素比较</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void heap_adjust(int *arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">int tmp = arr[start];</span><br><span class="line">for (int i = 2 * start + 1; i &lt;= end; i = i * 2 + 1)</span><br><span class="line">&#123;</span><br><span class="line">if (i + 1 &lt;= end &amp;&amp; arr[i]&gt;arr[i + 1])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if (tmp &gt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">arr[start] = arr[i];</span><br><span class="line">start = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">void heap_sort(int *arr, int length)</span><br><span class="line">&#123;</span><br><span class="line">//调整成小根堆</span><br><span class="line">for (int i = (length - 1 - 1) / 2; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">heap_adjust(arr, i, length - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int * find_max_N(int *arr, int len,int n)</span><br><span class="line">&#123;</span><br><span class="line">if (arr == NULL || len &lt; n||n&lt;1)return NULL;</span><br><span class="line">int *brr = new int[n];//先让brr为arr的前n个</span><br><span class="line">memcpy(brr, arr, sizeof(int)* n);</span><br><span class="line">heap_sort(brr, n);//把前n个调整为小根堆</span><br><span class="line">for (int i = n; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[i]&gt;brr[0])//如果有值比brr[0]大，则进行赋值后再次调整</span><br><span class="line">&#123;</span><br><span class="line">brr[0] = arr[i];</span><br><span class="line">heap_adjust(brr, 0, n-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return brr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用堆排序的思想，时间复杂度为O(n*logk),空间复杂度为O(K)</p><h1 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h1><p>使用快速排序划分的做法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在n个数中求最大的K个数&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://wanyaoqi.top/categories/Algorithm/"/>
    
    
      <category term="C++" scheme="http://wanyaoqi.top/tags/C/"/>
    
  </entry>
  
</feed>
