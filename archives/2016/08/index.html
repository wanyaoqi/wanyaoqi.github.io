<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>归档: 2016/8 | Yaoqi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="wanyaoqi">
  
  
  <meta name="description" content="面对疾风吧！！！">
<meta property="og:type" content="website">
<meta property="og:title" content="Yaoqi's Blog">
<meta property="og:url" content="http://yoursite.com/archives/2016/08/index.html">
<meta property="og:site_name" content="Yaoqi's Blog">
<meta property="og:description" content="面对疾风吧！！！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yaoqi's Blog">
<meta name="twitter:description" content="面对疾风吧！！！">
  
    <link rel="alternate" href="/atom.xml" title="Yaoqi&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Yaoqi&#39;s Blog</a></h1>
    <p><a href="/">coding</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">


<h2 class="archives-title"><span>2016</span></h2>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/20/stl_deque_2/">
  <time datetime="2016-08-20T02:52:35.000Z">
    2016-08-20
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/20/stl_deque_2/">STL deque——part 2</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push pop"></a>push pop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在deque末尾添加元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;   </span><br><span class="line">      <span class="comment">// 当前缓冲区还有空间  </span></span><br><span class="line">      construct(finish.cur, t); <span class="comment">// 直接在可用空间构建  </span></span><br><span class="line">      ++finish.cur; <span class="comment">// 调整finish迭代器  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 当前缓冲区无可用空间（last不能存储元素用）  </span></span><br><span class="line">      push_back_aux(t);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在deque头添加元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;     <span class="comment">// 当前缓冲区还有空间  </span></span><br><span class="line">      construct(start.cur - <span class="number">1</span>, t);   </span><br><span class="line">      --start.cur;        </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前缓冲区无空间可用了  </span></span><br><span class="line">      push_front_aux(t);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删掉末尾元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;<span class="comment">//最后一个缓冲区（finish指的缓冲区）有多于一个元素（含一个）  </span></span><br><span class="line">      --finish.cur;       </span><br><span class="line">      destroy(finish.cur);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      <span class="comment">// 最后一个缓冲区无元素  </span></span><br><span class="line">      pop_back_aux();       <span class="comment">// 这里会进行缓冲区的释放工作  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在deque头删除元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;  </span><br><span class="line">      <span class="comment">// start.node所指缓冲区有多余一个元素（不含一个）  </span></span><br><span class="line">      destroy(start.cur);     </span><br><span class="line">      ++start.cur;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">      <span class="comment">// start.node所指缓冲区只有一个元素  </span></span><br><span class="line">      pop_front_aux();      <span class="comment">// 这里会进行缓冲区释放工作  </span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_back_aux(<span class="keyword">const</span> value_type&amp; t) &#123;  </span><br><span class="line">  value_type t_copy = t;  </span><br><span class="line">  reserve_map_at_back();        <span class="comment">//  若符合某重条件则必须重换一个map  </span></span><br><span class="line">  *(finish.node + <span class="number">1</span>) = allocate_node(); <span class="comment">// 配置一个新结点（缓冲区）  </span></span><br><span class="line">  __STL_TRY &#123;  </span><br><span class="line">    construct(finish.cur, t_copy);      <span class="comment">// 设置值  </span></span><br><span class="line">    finish.set_node(finish.node + <span class="number">1</span>);   <span class="comment">// 改变finish，令其指向新结点  </span></span><br><span class="line">    finish.cur = finish.first;          <span class="comment">// 设置 finish 的状态  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 只有当start.cur == start.first才会调用。  </span></span><br><span class="line"><span class="comment">// 第一个缓冲区没有未用空间时才会调用。和上面实现类似  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_front_aux(<span class="keyword">const</span> value_type&amp; t) &#123;  </span><br><span class="line">  value_type t_copy = t;  </span><br><span class="line">  reserve_map_at_front();         </span><br><span class="line">  *(start.node - <span class="number">1</span>) = allocate_node();    </span><br><span class="line">  __STL_TRY &#123;  </span><br><span class="line">    start.set_node(start.node - <span class="number">1</span>);       </span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;           </span><br><span class="line">    construct(start.cur, t_copy);         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只有当finish.cur == finish.first才会调用  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::pop_back_aux() &#123;  </span><br><span class="line">  deallocate_node(finish.first);      </span><br><span class="line">  finish.set_node(finish.node - <span class="number">1</span>);   </span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;       </span><br><span class="line">  destroy(finish.cur);        </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 只有当start.cur == start.last - 1时才会调用  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::pop_front_aux() &#123;  </span><br><span class="line">  destroy(start.cur);                 </span><br><span class="line">  deallocate_node(start.first);   </span><br><span class="line">  start.set_node(start.node + <span class="number">1</span>);  </span><br><span class="line">  start.cur = start.first;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在map尾添加缓冲区  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>))  </span><br><span class="line">    <span class="comment">//map空间不够用，则开辟新的map空间，把原来map内容拷贝过来。释放原来的  </span></span><br><span class="line">      reallocate_map(nodes_to_add, <span class="literal">false</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在map头添加缓冲区  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)  </span><br><span class="line">      reallocate_map(nodes_to_add, <span class="literal">true</span>);     </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//添加map结点，指向新的缓冲区，add_at_front=true添加在map头，否则添加在尾  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::reallocate_map(size_type nodes_to_add,  </span><br><span class="line">                                              <span class="keyword">bool</span> add_at_front) &#123;  </span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;  </span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;  </span><br><span class="line">  </span><br><span class="line">  map_pointer new_nstart;  </span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;  </span><br><span class="line">    new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span>   </span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)  </span><br><span class="line">      copy(start.node, finish.node + <span class="number">1</span>, new_nstart);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">    size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">// 配置新的结点，准备给map使用  </span></span><br><span class="line">    map_pointer new_map = map_allocator::allocate(new_map_size);  </span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span>  </span><br><span class="line">                         + (add_at_front ? nodes_to_add : <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">// 把原map 內容拷贝  </span></span><br><span class="line">    copy(start.node, finish.node + <span class="number">1</span>, new_nstart);  </span><br><span class="line">    <span class="comment">// 释放放原map  </span></span><br><span class="line">    map_allocator::deallocate(<span class="built_in">map</span>, map_size);  </span><br><span class="line">    <span class="comment">// 设置新map起始位置和大小  </span></span><br><span class="line">    <span class="built_in">map</span> = new_map;  </span><br><span class="line">    map_size = new_map_size;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新设置迭代器 start 和 finish  </span></span><br><span class="line">  start.set_node(new_nstart);  </span><br><span class="line">  finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line"># insert</span><br><span class="line">  </span><br><span class="line">```cpp    </span><br><span class="line">  <span class="comment">// 在position 处插入一個元素，其值为 x  </span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;      <span class="comment">// position是deque的最前端，则调用push_front()</span></span><br><span class="line">      push_front(x);      </span><br><span class="line">      <span class="keyword">return</span> start;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;   <span class="comment">// position是deque的最末端，则调用push_back()</span></span><br><span class="line">      push_back(x);  </span><br><span class="line">      iterator tmp = finish;  </span><br><span class="line">      --tmp;  </span><br><span class="line">      <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> insert_aux(position, x);       <span class="comment">// 都不是就交给insert_aux 去做  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//在pos处插入一个元素，值为x。要判断插入点距头更近还是尾更近</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;  </span><br><span class="line">  difference_type index = pos - start;    </span><br><span class="line">  value_type x_copy = x;  </span><br><span class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;    <span class="comment">//插入点之前的元素少</span></span><br><span class="line">    push_front(front());          </span><br><span class="line">    iterator front1 = start;  </span><br><span class="line">    ++front1;  </span><br><span class="line">    iterator front2 = front1;  </span><br><span class="line">    ++front2;  </span><br><span class="line">    pos = start + index;  </span><br><span class="line">    iterator pos1 = pos;  </span><br><span class="line">    ++pos1;  </span><br><span class="line">    copy(front2, pos1, front1);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;                      <span class="comment">//插入点之后的元素少</span></span><br><span class="line">    push_back(back());        </span><br><span class="line">    iterator back1 = finish;  </span><br><span class="line">    --back1;  </span><br><span class="line">    iterator back2 = back1;  </span><br><span class="line">    --back2;  </span><br><span class="line">    pos = start + index;  </span><br><span class="line">    copy_backward(pos, back2, back1);     </span><br><span class="line">  &#125;  </span><br><span class="line">  *pos = x_copy;      </span><br><span class="line">  <span class="keyword">return</span> pos;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整deque的大小。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; len)   <span class="comment">//如果deque变小，直接擦除掉多余的元素</span></span><br><span class="line">      erase(start + new_size, finish);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      insert(finish, new_size - len, x);  <span class="comment">//如果deque变大，则在deque后面插入元素补充</span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; resize(new_size, value_type()); &#125;  </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">## erase</span><br><span class="line">```cpp                          </span><br><span class="line">  <span class="comment">// 清除 pos 所指的元素。  </span></span><br><span class="line">  <span class="comment">//判断pos距离头近还是距离尾近，距离那个位置近就移动那个位置的元素，保证移动元素个数最少  </span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;  </span><br><span class="line">    iterator next = pos;  </span><br><span class="line">    ++next;  </span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// pos和deque开头元素的个数  </span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>)) &#123;           <span class="comment">// size() &gt;&gt; 1为size()/2  </span></span><br><span class="line">    <span class="comment">//如果pos距离deque头比较近的话，deque的开头到pos元素向后移  </span></span><br><span class="line">      copy_backward(start, pos, next);    </span><br><span class="line">      pop_front();              <span class="comment">// 移动后，删除第一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;                  <span class="comment">// 否则pos+1到结尾元素向前移，  </span></span><br><span class="line">      copy(next, finish, pos);    </span><br><span class="line">      pop_back();                 </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> start + index;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//擦除两个迭代器之间的元素  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::iterator   </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123; <span class="comment">// 如果是清除整个 deque  </span></span><br><span class="line">    clear();                            <span class="comment">// 直接调用 clear() 即可  </span></span><br><span class="line">    <span class="keyword">return</span> finish;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">    difference_type n = last - first;           <span class="comment">// 擦除区间长度  </span></span><br><span class="line">    difference_type elems_before = first - start;   <span class="comment">// 擦除区间前方元素的个数  </span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;       <span class="comment">// 如果前方的元素少，  </span></span><br><span class="line">      copy_backward(start, first, last);        <span class="comment">// 前方元素向后移（覆盖擦除区间）  </span></span><br><span class="line">      iterator new_start = start + n;           <span class="comment">// deque 的新起点  </span></span><br><span class="line">      destroy(start, new_start);                <span class="comment">// 多于元素析构  </span></span><br><span class="line">      <span class="comment">// 释放多于元素所占内存  </span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)  </span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  </span><br><span class="line">      start = new_start;      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 后方元素更少  </span></span><br><span class="line">      copy(last, finish, first);    <span class="comment">//后方元素向前移动（覆盖擦除区间）     </span></span><br><span class="line">      iterator new_finish = finish - n;   </span><br><span class="line">      destroy(new_finish, finish);        </span><br><span class="line">      <span class="comment">// 释放多于元素所占内存</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)  </span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  </span><br><span class="line">      finish = new_finish;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> start + elems_before;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空deque。最后保留了一个缓冲区，这是deque的策略，也是其初始状态  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::clear() &#123;  </span><br><span class="line">  <span class="comment">//头尾以外的缓冲区，它们肯定是满的。  </span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;  </span><br><span class="line"></span><br><span class="line">    destroy(*node, *node + buffer_size());  </span><br><span class="line">    data_allocator::deallocate(*node, buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123;  <span class="comment">// 至少有2个以上（含）缓冲区  </span></span><br><span class="line">    destroy(start.cur, start.last); <span class="comment">// 头缓冲区元素析构  </span></span><br><span class="line">    destroy(finish.first, finish.cur); <span class="comment">// 尾缓冲区元素析构  </span></span><br><span class="line">    <span class="comment">// 释放尾缓冲区，保留了头缓冲区  </span></span><br><span class="line">    data_allocator::deallocate(finish.first, buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 只有一个缓冲区  </span></span><br><span class="line">    destroy(start.cur, finish.cur); <span class="comment">// 析构，但是不释放  </span></span><br><span class="line">  </span><br><span class="line">  finish = start;   <span class="comment">// 调整迭代器，deque为空  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/18/stl_deque_1/">
  <time datetime="2016-08-18T13:59:56.000Z">
    2016-08-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/18/stl_deque_1/">STL deque——part 1</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h1><p>deque是一个双端队列<br><img src="/imgs/stl_deque/deque_1.png" alt="1"><br><img src="/imgs/stl_deque/deque_2.png" alt="2"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;   </span><br><span class="line"><span class="keyword">class</span> <span class="built_in">deque</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  ···</span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members  </span></span><br><span class="line">  iterator start;       <span class="comment">// start.cur指向deque的第一个结点  </span></span><br><span class="line">  iterator finish;  <span class="comment">// finish.cur指向迭代器deque的最后一个结点的后一个元素  </span></span><br><span class="line">  </span><br><span class="line">  map_pointer <span class="built_in">map</span>;  <span class="comment">// 指向中控器。其实是指向中控器的第一个结点。  </span></span><br><span class="line">                    <span class="comment">//  中控器是连续的，map_size定义了中控器的大小。  </span></span><br><span class="line">                           </span><br><span class="line">  size_type map_size;   <span class="comment">// 中控器的大小。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/imgs/stl_deque/deque_3.png" alt="3"></p>
<h1 id="deque-迭代器"><a href="#deque-迭代器" class="headerlink" title="deque 迭代器"></a>deque 迭代器</h1><p><img src="/imgs/stl_deque/deque_4.png" alt="4"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">此函数用来计算缓冲区的大小 </span><br><span class="line">如果n不等于0，那么返回n，开发者自己决定 </span><br><span class="line">    否则：如果sz小于512，返回512/sz </span><br><span class="line">    	如果sz大于512，返回1 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//deque的迭代器，未继承std::iterator  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr, <span class="keyword">size_t</span> BufSiz&gt;  </span><br><span class="line"><span class="keyword">struct</span> __deque_iterator &#123;     </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;      iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//没有继承std::iterator，自己定义5个迭代器相应型别。  </span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                 <span class="comment">// (2)  </span></span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;              <span class="comment">// (3)  </span></span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                <span class="comment">// (4)  </span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;    <span class="comment">// (5)  </span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;  <span class="comment">//注意，是指针的指针  </span></span><br><span class="line">  <span class="comment">//map_pointer指向中控器，中控器的存储的是指针，指向node-buf结点缓冲区  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  T* cur;   <span class="comment">// 迭代器所指元素  </span></span><br><span class="line">  T* first; <span class="comment">// 迭代器所指元素所在缓冲区的开头  </span></span><br><span class="line">  T* last;  <span class="comment">// 迭代器所指元素所在缓冲区的结尾（结尾包含在缓冲区内）  </span></span><br><span class="line">  map_pointer node;<span class="comment">//指向中控器的结点，这个结点指向迭代器所指元素所在的缓冲区  </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//迭代器的构造函数  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//x是迭代器所指结点，y为中控器中的结点的值，指向x所指缓冲区  </span></span><br><span class="line">  __deque_iterator(T* x, map_pointer y)   </span><br><span class="line">    : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125;  </span><br><span class="line">    <span class="comment">//默认构造函数  </span></span><br><span class="line">  __deque_iterator() : cur(<span class="number">0</span>), first(<span class="number">0</span>), last(<span class="number">0</span>), node(<span class="number">0</span>) &#123;&#125;  </span><br><span class="line">    <span class="comment">//用一个迭代器x初始化本迭代器  </span></span><br><span class="line">  __deque_iterator(<span class="keyword">const</span> iterator&amp; x)  </span><br><span class="line">    : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器需要重载的运算符  </span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;   </span><br><span class="line"><span class="comment">/* </span><br><span class="line">两个迭代器之间的距离。这两个迭代器可能不在同一个buffer上。 </span><br><span class="line">*/</span>  </span><br><span class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +  </span><br><span class="line">      (cur - first) + (x.last - x.cur);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* </span><br><span class="line">    迭代器前进一步。 </span><br><span class="line">    先++cur，再判断cur==last。说明cur不会指向last的。last所指空间不存内容 </span><br><span class="line">  */</span>  </span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;  </span><br><span class="line">    ++cur;              <span class="comment">// 前进一步  </span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;      <span class="comment">// 到了所在缓冲区的尾端了  </span></span><br><span class="line">      set_node(node + <span class="number">1</span>);   <span class="comment">// 切换到下一个缓冲区  </span></span><br><span class="line">      cur = first;          <span class="comment">//   的第一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   </span><br><span class="line">  &#125;  </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    ++*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//迭代器往回走一步。  </span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123; <span class="comment">// 如果在所在缓冲区的头部  </span></span><br><span class="line">      set_node(node - <span class="number">1</span>);   <span class="comment">// 切换到前一个缓冲区  </span></span><br><span class="line">      cur = last;           <span class="comment">//   的最后一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    --cur;              <span class="comment">// 直接往回走一步  </span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    --*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* </span><br><span class="line">    迭代器向前进或后退n步（取决于n的正负）。这是支持random access iterator 所必须的操作。 </span><br><span class="line">    如果这个操作不会是迭代器走出当前所在缓冲区，直接更改cur即可。 </span><br><span class="line">    如果这个操作使迭代器走出当前所在缓冲区，要计算出操作后在哪个缓冲区的哪个位置。 </span><br><span class="line">  */</span>  </span><br><span class="line">  self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;  </span><br><span class="line">    difference_type offset = n + (cur - first);  </span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))  </span><br><span class="line">      <span class="comment">// 不会走出当前所在缓冲区  </span></span><br><span class="line">      cur += n;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="comment">// 走出了当前所在缓冲区  </span></span><br><span class="line">      difference_type node_offset =  </span><br><span class="line">        offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())  </span><br><span class="line">                   : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;  </span><br><span class="line">      <span class="comment">// 切换缓冲区  </span></span><br><span class="line">      set_node(node + node_offset);  </span><br><span class="line">      <span class="comment">// 找到切换缓冲区后，迭代器所指向的元素  </span></span><br><span class="line">      cur = first + (offset - node_offset * difference_type(buffer_size()));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="comment">//调用operator+=  </span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">  <span class="comment">// 以上调用了operator*, operator+  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*迭代器关于比较的运算符的重载*/</span>  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//切换缓冲区，更改了first和last，但是未更改cur  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;  </span><br><span class="line">    node = new_node;  </span><br><span class="line">    first = *new_node;  </span><br><span class="line">    last = first + difference_type(buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/imgs/stl_deque/deque_5.png" alt="5"></p>
<h1 id="deque的定义"><a href="#deque的定义" class="headerlink" title="deque的定义"></a>deque的定义</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;   </span><br><span class="line">class deque &#123;  </span><br><span class="line">public:                         // Basic types  </span><br><span class="line">  typedef T value_type;  </span><br><span class="line">  typedef value_type* pointer;  </span><br><span class="line">  typedef const value_type* const_pointer;  </span><br><span class="line">  typedef value_type&amp; reference;  </span><br><span class="line">  typedef const value_type&amp; const_reference;  </span><br><span class="line">  typedef size_t size_type;  </span><br><span class="line">  typedef ptrdiff_t difference_type;  </span><br><span class="line">  </span><br><span class="line">public:                         // 迭代器  </span><br><span class="line">  typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;              iterator;  </span><br><span class="line">  typedef __deque_iterator&lt;T, const T&amp;, const T&amp;, BufSiz&gt;  const_iterator;  </span><br><span class="line"></span><br><span class="line">  typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  </span><br><span class="line">  typedef reverse_iterator&lt;iterator&gt; reverse_iterator;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">protected:                      // Internal typedefs  </span><br><span class="line">  // 指向中控器，是指针的指针（pointer of pointer of T）  </span><br><span class="line">  typedef pointer* map_pointer;   </span><br><span class="line">  // 空间配置器，用来配置缓冲区  </span><br><span class="line">  typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  </span><br><span class="line">  // 空间配置器，用来配置中控器  </span><br><span class="line">  typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator;  </span><br><span class="line">  </span><br><span class="line">  static size_type buffer_size() &#123;  </span><br><span class="line">    return __deque_buf_size(BufSiz, sizeof(value_type));  </span><br><span class="line">  &#125;  </span><br><span class="line">  //默认中控器大小为8  </span><br><span class="line">  static size_type initial_map_size() &#123; return 8; &#125;  </span><br><span class="line">  </span><br><span class="line">protected:                      // Data members  </span><br><span class="line">  iterator start;       // start.cur指向deque的第一个结点  </span><br><span class="line">  iterator finish;  // finish.cur指向迭代器deque的最后一个结点的后一个元素  </span><br><span class="line">  </span><br><span class="line">  map_pointer map;  // 指向中控器。其实是指向中控器的第一个结点。  </span><br><span class="line">                    //  中控器是连续的，map_size定义了中控器的大小。  </span><br><span class="line">                           </span><br><span class="line">  size_type map_size;   // 中控器的大小。  </span><br><span class="line">  </span><br><span class="line">public:                         // 对外的接口  </span><br><span class="line">  iterator begin() &#123; return start; &#125;  </span><br><span class="line">  iterator end() &#123; return finish; &#125;  </span><br><span class="line">  const_iterator begin() const &#123; return start; &#125;  </span><br><span class="line">  const_iterator end() const &#123; return finish; &#125;  </span><br><span class="line">  </span><br><span class="line">  reverse_iterator rbegin() &#123; return reverse_iterator(finish); &#125;  </span><br><span class="line">  reverse_iterator rend() &#123; return reverse_iterator(start); &#125;  </span><br><span class="line">  const_reverse_iterator rbegin() const &#123;  </span><br><span class="line">    return const_reverse_iterator(finish);  </span><br><span class="line">  &#125;  </span><br><span class="line">  const_reverse_iterator rend() const &#123;  </span><br><span class="line">    return const_reverse_iterator(start);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference operator[](size_type n) &#123;  </span><br><span class="line">    return start[difference_type(n)]; // 调用 __deque_iterator&lt;&gt;::operator[]  </span><br><span class="line">  &#125;  </span><br><span class="line">  const_reference operator[](size_type n) const &#123;  </span><br><span class="line">    return start[difference_type(n)];  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference front() &#123; return *start; &#125; // 调用 __deque_iterator&lt;&gt;::operator*  </span><br><span class="line">    </span><br><span class="line">  //取出最后一个元素  </span><br><span class="line">  reference back() &#123;  </span><br><span class="line">    iterator tmp = finish;    </span><br><span class="line">    --tmp;  // 调用 __deque_iterator&lt;&gt;::operator--  </span><br><span class="line">    return *tmp;    // 调用 __deque_iterator&lt;&gt;::operator*  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  //返回第一个元素，并不删除  </span><br><span class="line">  const_reference front() const &#123; return *start; &#125;  </span><br><span class="line">  const_reference back() const &#123;  </span><br><span class="line">    const_iterator tmp = finish;  </span><br><span class="line">    --tmp;  </span><br><span class="line">    return *tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  //两分号但是合法</span><br><span class="line">  size_type size() const &#123; return finish - start;; &#125;   </span><br><span class="line">    //deque最大容量。  </span><br><span class="line">  size_type max_size() const &#123; return size_type(-1); &#125;  </span><br><span class="line">  //下面调用了operator::iterator==  </span><br><span class="line">  bool empty() const &#123; return finish == start; &#125;  </span><br><span class="line">  </span><br><span class="line">public:       </span><br><span class="line">    </span><br><span class="line">   //默认构造函数  </span><br><span class="line">  deque(): start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    create_map_and_nodes(0);  </span><br><span class="line">  &#125;  </span><br><span class="line">//用一个deque构建新的deque  </span><br><span class="line">  deque(const deque&amp; x)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    create_map_and_nodes(x.size());  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      uninitialized_copy(x.begin(), x.end(), start);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //commit or rollback  </span><br><span class="line">    __STL_UNWIND(destroy_map_and_nodes());  </span><br><span class="line">  &#125;  </span><br><span class="line">//构建大小为n，元素值为value的deque  </span><br><span class="line">  deque(size_type n, const value_type&amp; value)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  deque(int n, const value_type&amp; value)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  deque(long n, const value_type&amp; value)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">//构建大小为n的deque，默认值为T(),说明deque容器的元素要有默认构造函数  </span><br><span class="line">  explicit deque(size_type n)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value_type());  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  template &lt;class InputIterator&gt;  </span><br><span class="line">  deque(InputIterator first, InputIterator last)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    range_initialize(first, last, iterator_category(first));  </span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  ~deque() &#123;  </span><br><span class="line">    destroy(start, finish);  </span><br><span class="line">    destroy_map_and_nodes();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  deque&amp; operator= (const deque&amp; x) &#123;  </span><br><span class="line">    const size_type len = size();  </span><br><span class="line">    if (&amp;x != this) &#123;  </span><br><span class="line">      if (len &gt;= x.size())  </span><br><span class="line">        erase(copy(x.begin(), x.end(), start), finish);  </span><br><span class="line">      else &#123;  </span><br><span class="line">        const_iterator mid = x.begin() + difference_type(len);  </span><br><span class="line">        copy(x.begin(), mid, start);  </span><br><span class="line">        insert(finish, mid, x.end());  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return *this;  </span><br><span class="line">  &#125;          </span><br><span class="line">  </span><br><span class="line">  void swap(deque&amp; x) &#123;  </span><br><span class="line">    __STD::swap(start, x.start);  </span><br><span class="line">    __STD::swap(finish, x.finish);  </span><br><span class="line">    __STD::swap(map, x.map);  </span><br><span class="line">    __STD::swap(map_size, x.map_size);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/18/stl_list_2/">
  <time datetime="2016-08-17T16:31:32.000Z">
    2016-08-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/18/stl_list_2/">STL list ——part 2</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="transfer、splice"><a href="#transfer、splice" class="headerlink" title="transfer、splice"></a>transfer、splice</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将first到last內的所有元素搬移到position 前，不包括last元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (position != last) &#123;  </span><br><span class="line"></span><br><span class="line">    (*(link_type((*last.node).prev))).next = position.node;          </span><br><span class="line">    (*(link_type((*first.node).prev))).next = last.node;       </span><br><span class="line">    (*(link_type((*position.node).prev))).next = first.node; </span><br><span class="line">        </span><br><span class="line">    link_type tmp = link_type((*position.node).prev);        </span><br><span class="line">    (*position.node).prev = (*last.node).prev;                </span><br><span class="line">    (*last.node).prev = (*first.node).prev;                  </span><br><span class="line">    (*first.node).prev = tmp;                            </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁移过程如图：<br><img src="/imgs/stl_list/transfer.png" alt="transfer"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 x 链表插入到 position 所指位置之前。x 必须不能是 *this。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span><br><span class="line"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (!x.empty())   </span><br><span class="line">    transfer(position, x.begin(), x.end());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 將i所指元素插入到 position 所指位置之前。position 和i 可在同一个list。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span></span><br><span class="line"></span>&#123;  </span><br><span class="line">  iterator j = i;  </span><br><span class="line">  ++j;  </span><br><span class="line">  <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;  </span><br><span class="line">  transfer(position, i, j);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 將 [first,last) 內的所有元素插入到 position 所指位置之前。  </span></span><br><span class="line"><span class="comment">// position 和[first,last)可指在同一个list，  </span></span><br><span class="line"><span class="comment">// 但position不能位于[first,last)之內。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator first, iterator last)</span></span><br><span class="line"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (first != last)   </span><br><span class="line">    transfer(position, first, last);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将x合并到*this上面。两个链表都要先经过递增排序。相当于合并排序的最后一步  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span><br><span class="line">&#123;  </span><br><span class="line">  iterator first1 = begin();  </span><br><span class="line">  iterator last1 = end();  </span><br><span class="line">  iterator first2 = x.begin();  </span><br><span class="line">  iterator last2 = x.end();  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//前提是两个链表都已经递增排序好了  </span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">      iterator next = first2;  </span><br><span class="line">      transfer(first1, first2, ++next);  </span><br><span class="line">      first2 = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      ++first1;  </span><br><span class="line">  <span class="keyword">if</span> (first2 != last2) transfer(last1, first2, last2);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将 list逆置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::reverse() </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//如果链表是空，或者只有一个元素，就不做任何处理  </span></span><br><span class="line">    <span class="comment">//不是用size()==0或size()==1来判断，因为这样比较慢  </span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  ++first;  </span><br><span class="line">  <span class="keyword">while</span> (first != end()) &#123;  </span><br><span class="line">    iterator old = first;  </span><br><span class="line">    ++first;  </span><br><span class="line">    transfer(begin(), old, first);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="list-sort"><a href="#list-sort" class="headerlink" title="list sort"></a>list sort</h1><p>list不能采用STL sort()算法，必须使用自己的sort；因为STL sort只能接收随机流迭代器<br>SGI实现版：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::sort() &#123;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; carry;  </span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fill = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">while</span> (!empty()) </span><br><span class="line">  &#123;  </span><br><span class="line">    carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());  <span class="comment">//取第一个放入carry中</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())	     <span class="comment">//counter[i]为空则跳过</span></span><br><span class="line">    &#123;      </span><br><span class="line">      counter[i].merge(carry);                   <span class="comment">//有序的合并到counter</span></span><br><span class="line">      carry.swap(counter[i++]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    carry.swap(counter[i]);           <span class="comment">//将carry中的数据交换到counter[i]中</span></span><br><span class="line">    <span class="keyword">if</span> (i == fill) ++fill;  </span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i)       <span class="comment">//将数组中所有的数据合并到最后一个桶中</span></span><br><span class="line">     counter[i].merge(counter[i<span class="number">-1</span>]);  </span><br><span class="line">  swap(counter[fill<span class="number">-1</span>]);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//两个链表交换，就是他们的node头结点交换 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	__STD::swap(node, x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sort的过程是一个循环归并的过程，定义一个tmp和一个list数组</p>
<pre><code>假设有这样以组数: 3 5 1 2 7 6 9    
1.取 3 放入carry中，此时不满足循环条件i==fill，将carry中数据换入counter[0]中，carry为空，counter[0]为{3};
2.取 5 放入carry中，carry与counter[0] merge并交换，得到counter为空，counter[1]为{3，5};
3.取 1 放如carry中,此时counter[0]为空，不进入while循环，将 1 放入 counter[0]中，counter[0]为{1};
4.去 2 放入carry中，和counter[0] merge 后又与counter[1] merge放入counter[2]中，counter[2]为{1，2，3，5}
counter[0]和counter[1]为空；
</code></pre><p>一直循环下去。。直到list为空。<br>然后最后面for循环将counter中的合并到最后一个中，在换给list，即完成了排序；</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/15/stl_list_1/">
  <time datetime="2016-08-15T15:19:53.000Z">
    2016-08-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/15/stl_list_1/">STL list ——part 1</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a>list结构</h1><p>STL list是一个环形双向链表 ，结点结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> __list_node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prev;<span class="comment">//其实可以设为__list_node&lt;T&gt;*</span></span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>list是一个双向链表,其迭代器可以向前移、向后移,因此迭代器类型为bidirectional_iterator_tag<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有继承 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr&gt;  </span><br><span class="line"><span class="keyword">struct</span> __list_iterator &#123;   </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为了支持STL型别标准，自己定义5个类别  </span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;           </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;          </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;             </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;   </span><br><span class="line">  </span><br><span class="line">  link_type node;  <span class="comment">// 指向list的结点指针 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造函数  </span></span><br><span class="line">  __list_iterator(link_type x) : node(x) &#123;&#125;  </span><br><span class="line">  __list_iterator() &#123;&#125;  </span><br><span class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器操作运算符重载</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125; </span><br><span class="line">       </span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;      </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR    </span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span>  </span></span><br><span class="line">      </span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;   </span><br><span class="line">    node = (link_type)((*node).next);     </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;    </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    ++*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;      </span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;   </span><br><span class="line">    node = (link_type)((*node).prev);   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;    </span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;   </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    --*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="list-定义"><a href="#list-定义" class="headerlink" title="list 定义"></a>list 定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt; <span class="comment">// 默认为 alloc 为配置器  </span></span><br><span class="line"><span class="keyword">class</span> <span class="built_in">list</span> &#123;  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;    </span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;  </span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;  </span><br><span class="line">  <span class="keyword">typedef</span> list_node* link_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span>  </span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,  </span><br><span class="line">  const_reference, difference_type&gt;  </span><br><span class="line">  const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,  </span><br><span class="line">  difference_type&gt;  </span><br><span class="line">  reverse_iterator;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  <span class="comment">//申请、释放结点 </span></span><br><span class="line">  <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::allocate(); &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::deallocate(p); &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;  </span><br><span class="line">    link_type p = get_node();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      construct(&amp;p-&gt;data, x);    </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(put_node(p));  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;  </span><br><span class="line">    destroy(&amp;p-&gt;data);       </span><br><span class="line">    put_node(p);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="comment">//初始化一个空链表，首尾相连  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    node = get_node();    </span><br><span class="line">    node-&gt;next = node;     </span><br><span class="line">    node-&gt;prev = node;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//初始化长为n的链表，值都为value  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), n, value);      <span class="comment">//先初始化一个空链表在插入n个结点</span></span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line">  <span class="comment">//以迭代器区间初始化一个链表  </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  <span class="comment">//</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//commit or rollback  </span></span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* __STL_MEMBER_TEMPLATES */</span>  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:   </span><br><span class="line">  link_type node; <span class="comment">//头结点  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="list元素操作"><a href="#list元素操作" class="headerlink" title="list元素操作"></a>list元素操作</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>list() { empty_initialize(); // 默认构造函数，空链表。

//构造长为n的链表
list(size_type n, const T&amp; value) { fill_initialize(n, value); } 

list(int n, const T&amp; value) { fill_initialize(n, value); }  

list(long n, const T&amp; value) { fill_initialize(n, value); } 

explicit list(size_type n) { fill_initialize(n, T()); }

//迭代器区间构造list   
template &lt;class InputIterator&gt;  
list(InputIterator first, InputIterator last){range_initialize(first, last);}

//拷贝构造list
list(const list&lt;T, Alloc&gt;&amp; x){range_initialize(x.begin(), x.end());}  
</code></pre><h2 id="push、pop、erase、insert、clear、remove、unique"><a href="#push、pop、erase、insert、clear、remove、unique" class="headerlink" title="push、pop、erase、insert、clear、remove、unique"></a>push、pop、erase、insert、clear、remove、unique</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span><br><span class="line">  </span>&#123; </span><br><span class="line">  	insert(begin(), x); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span><br><span class="line">  </span>&#123; </span><br><span class="line">   	insert(end(), x); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span><br><span class="line">  </span>&#123; </span><br><span class="line">  	erase(begin()); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span><br><span class="line">  </span>&#123;   </span><br><span class="line">    iterator tmp = end();  </span><br><span class="line">    erase(--tmp);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> <span class="comment">//在postition所指位置之前插入一个结点</span></span><br><span class="line">  </span>&#123;  </span><br><span class="line">    link_type tmp = create_node(x); <span class="comment">// 申请一个结点并用x初始化   </span></span><br><span class="line">    tmp-&gt;next = position.node;  </span><br><span class="line">    tmp-&gt;prev = position.node-&gt;prev;  </span><br><span class="line">    <span class="comment">//prev和next指针都是void*，所以需要指针类型转换  </span></span><br><span class="line">    (link_type(position.node-&gt;prev))-&gt;next = tmp;  </span><br><span class="line">    position.node-&gt;prev = tmp;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span>  <span class="comment">//移除position所指结点 </span></span><br><span class="line">  </span>&#123;  </span><br><span class="line">    link_type next_node = link_type(position.node-&gt;next);  </span><br><span class="line">    link_type prev_node = link_type(position.node-&gt;prev);  </span><br><span class="line">    prev_node-&gt;next = next_node;  </span><br><span class="line">    next_node-&gt;prev = prev_node;  </span><br><span class="line">    destroy_node(position.node);  </span><br><span class="line">    <span class="keyword">return</span> iterator(next_node);  </span><br><span class="line">  &#125;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;   </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::clear()    <span class="comment">// 清除所有结点 </span></span><br><span class="line">&#123;  </span><br><span class="line">  link_type cur = (link_type) node-&gt;next; <span class="comment">// begin()  </span></span><br><span class="line">  <span class="keyword">while</span> (cur != node) &#123;   <span class="comment">//遍历结点</span></span><br><span class="line">    link_type tmp = cur;  </span><br><span class="line">    cur = (link_type) cur-&gt;next;  </span><br><span class="line">    destroy_node(tmp);    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 恢复头结点状态</span></span><br><span class="line">  node-&gt;next = node;  </span><br><span class="line">  node-&gt;prev = node;  </span><br><span class="line">&#125; 	  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::remove(<span class="keyword">const</span> T&amp; value) <span class="comment">// 将数值为value的结点移除</span></span><br><span class="line">&#123;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  iterator last = end();  </span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;    </span><br><span class="line">    iterator next = first;  </span><br><span class="line">    ++next;  </span><br><span class="line">    <span class="keyword">if</span> (*first == value) erase(first);  <span class="comment">// 移除  </span></span><br><span class="line">    first = next;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::unique()<span class="comment">// 移除数值相同的连续元素 ，只有相同的连续元素才会被移除！！</span></span><br><span class="line">&#123;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  iterator last = end();  </span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;  </span><br><span class="line">  iterator next = first;  </span><br><span class="line">  <span class="keyword">while</span> (++next != last) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (*first == *next)</span><br><span class="line">      erase(next);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      first = next;  </span><br><span class="line">    next = first;    <span class="comment">//调整范围</span></span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span><br><span class="line"></span>&#123;  </span><br><span class="line">    size_type result = <span class="number">0</span>;  </span><br><span class="line">    distance(begin(), end(), result);  <span class="comment">// 在&lt;stl_iterator.h&gt;定义，result是引用传递  </span></span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/14/stl_vector/">
  <time datetime="2016-08-13T17:53:03.000Z">
    2016-08-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/14/stl_vector/">STL vector</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h1><p>   vector 数据安排上和数组非常相似，差别在于数组大小定义后不能在改变而vector内部会自行扩充空间容纳新元素</p>
<h1 id="vector-定义"><a href="#vector-定义" class="headerlink" title="vector 定义"></a>vector 定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty, <span class="keyword">class</span> _A = allocator&lt;_Ty&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;_Ty, _A&gt;     _Myt;</span><br><span class="line">	<span class="keyword">typedef</span> _A                  allocator_type;</span><br><span class="line">	<span class="keyword">typedef</span> _A::size_type       size_type;</span><br><span class="line">	<span class="keyword">typedef</span> _A::difference_type difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> _A::pointer         _Tptr;</span><br><span class="line">	<span class="keyword">typedef</span> _A::const_pointer   _Ctptr;</span><br><span class="line">	<span class="keyword">typedef</span> _A::reference       reference;</span><br><span class="line">	<span class="keyword">typedef</span> _A::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> _A::value_type      value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tptr               iterator;                <span class="comment">//vector迭代器就是本身的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> _Ctptr              const_iterator;</span><br><span class="line">	</span><br><span class="line">protect:	</span><br><span class="line">	_A allocator;                <span class="comment">//空间配置器</span></span><br><span class="line">	iterator _First, _Last, _End;<span class="comment">//正在使用的头，正在使用的尾，空间的尾</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">explicit vector(const _A&amp; _Al = _A())                 //简单的初始化成员变量</span><br><span class="line">	: allocator(_Al), _First(0), _Last(0), _End(0) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">explicit vector(size_type _N, const _Ty&amp; _V = _Ty(),  //初始化_N个_TY变量</span><br><span class="line">	const _A&amp; _Al = _A())</span><br><span class="line">	: allocator(_Al)</span><br><span class="line">	&#123;_First = allocator.allocate(_N, (void *)0);</span><br><span class="line">	_Ufill(_First, _N, _V);                       //这个函数后面会有，就是从_F开始构造_N个_V                   </span><br><span class="line">	_Last = _First + _N;</span><br><span class="line">	_End = _Last; &#125;</span><br><span class="line">	</span><br><span class="line">vector(const _Myt&amp; _X)                           //拷贝构造函数</span><br><span class="line">	: allocator(_X.allocator)</span><br><span class="line">	&#123;_First = allocator.allocate(_X.size(), (void *)0);</span><br><span class="line">	_Last = _Ucopy(_X.begin(), _X.end(), _First);</span><br><span class="line">	_End = _Last; &#125;</span><br><span class="line">	</span><br><span class="line">typedef const_iterator _It;</span><br><span class="line">vector(_It _F, _It _L, const _A&amp; _Al = _A())     //构造vector并在开始位置插入_F到_L间的数据</span><br><span class="line">	: allocator(_Al), _First(0), _Last(0), _End(0)</span><br><span class="line">	&#123;insert(begin(), _F, _L); &#125;</span><br></pre></td></tr></table></figure>
<h1 id="vector-元素操作"><a href="#vector-元素操作" class="headerlink" title="vector 元素操作"></a>vector 元素操作</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line">void resize(size_type _N, const _Ty&amp; _X = _Ty())  //resize手动改变vector容量</span><br><span class="line">	&#123;if (size() &lt; _N)</span><br><span class="line">		insert(end(), _N - size(), _X);</span><br><span class="line">	else if (_N &lt; size())</span><br><span class="line">		erase(begin() + _N, end()); &#125;</span><br><span class="line">size_type size() const //已用大小</span><br><span class="line">	&#123;return (_First == 0 ? 0 : _Last - _First); &#125;</span><br><span class="line"></span><br><span class="line">bool empty() const</span><br><span class="line">	&#123;return (size() == 0); &#125;</span><br><span class="line"></span><br><span class="line">reference operator[](size_type _P)</span><br><span class="line">	&#123;return (*(begin() + _P)); &#125;</span><br><span class="line"></span><br><span class="line">void push_back(const _Ty&amp; _X)     //在容器的最后插入一个元素</span><br><span class="line">	&#123;insert(end(), _X); &#125;</span><br><span class="line">void pop_back()                   //删除最后一个元素</span><br><span class="line">	&#123;erase(end() - 1); &#125;</span><br><span class="line"></span><br><span class="line">iterator insert(iterator _P, const _Ty&amp; _X = _Ty()) //插入一个,返回的迭代器指向的是</span><br><span class="line">	&#123;size_type _O = _P - begin();</span><br><span class="line">	insert(_P, 1, _X);</span><br><span class="line">	return (begin() + _O); &#125;</span><br><span class="line">	</span><br><span class="line">void insert(iterator _P, size_type _M, const _Ty&amp; _X) //从_P开始插入_M个_X元素</span><br><span class="line">	&#123;if (_End - _Last &lt; _M)</span><br><span class="line">		&#123;size_type _N = size() + (_M &lt; size() ? size() : _M);</span><br><span class="line">		iterator _S = allocator.allocate(_N, (void *)0);</span><br><span class="line">		iterator _Q = _Ucopy(_First, _P, _S);</span><br><span class="line">		_Ufill(_Q, _M, _X);</span><br><span class="line">		_Ucopy(_P, _Last, _Q + _M);</span><br><span class="line">		_Destroy(_First, _Last);</span><br><span class="line">		allocator.deallocate(_First, _End - _First);</span><br><span class="line">		_End = _S + _N;</span><br><span class="line">		_Last = _S + size() + _M;</span><br><span class="line">		_First = _S; &#125;</span><br><span class="line">	else if (_Last - _P &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_P, _Last, _P + _M);</span><br><span class="line">		_Ufill(_Last, _M - (_Last - _P), _X);</span><br><span class="line">		fill(_P, _Last, _X);</span><br><span class="line">		_Last += _M; &#125;</span><br><span class="line">	else if (0 &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_Last - _M, _Last, _Last);</span><br><span class="line">		copy_backward(_P, _Last - _M, _Last);</span><br><span class="line">		fill(_P, _P + _M, _X);</span><br><span class="line">		_Last += _M; &#125;&#125;</span><br><span class="line">		</span><br><span class="line">void insert(iterator _P, _It _F, _It _L)</span><br><span class="line">	&#123;size_type _M = 0;</span><br><span class="line">	_Distance(_F, _L, _M);</span><br><span class="line">	if (_End - _Last &lt; _M)</span><br><span class="line">		&#123;size_type _N = size() + (_M &lt; size() ? size() : _M);</span><br><span class="line">		iterator _S = allocator.allocate(_N, (void *)0);</span><br><span class="line">		iterator _Q = _Ucopy(_First, _P, _S);</span><br><span class="line">		_Q = _Ucopy(_F, _L, _Q);</span><br><span class="line">		_Ucopy(_P, _Last, _Q);</span><br><span class="line">		_Destroy(_First, _Last);</span><br><span class="line">		allocator.deallocate(_First, _End - _First);</span><br><span class="line">		_End = _S + _N;</span><br><span class="line">		_Last = _S + size() + _M;</span><br><span class="line">		_First = _S; &#125;</span><br><span class="line">	else if (_Last - _P &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_P, _Last, _P + _M);</span><br><span class="line">		_Ucopy(_F + (_Last - _P), _L, _Last);</span><br><span class="line">		copy(_F, _F + (_Last - _P), _P);</span><br><span class="line">		_Last += _M; &#125;</span><br><span class="line">	else if (0 &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_Last - _M, _Last, _Last);</span><br><span class="line">		copy_backward(_P, _Last - _M, _Last);</span><br><span class="line">		copy(_F, _L, _P);</span><br><span class="line">		_Last += _M; &#125;&#125;</span><br><span class="line">iterator erase(iterator _P)</span><br><span class="line">	&#123;copy(_P + 1, end(), _P);    // 从—_p+1开始往前挪</span><br><span class="line">	_Destroy(_Last - 1, _Last);</span><br><span class="line">	--_Last;</span><br><span class="line">	return (_P); &#125;</span><br><span class="line">iterator erase(iterator _F, iterator _L)</span><br><span class="line">	&#123;iterator _S = copy(_L, end(), _F);</span><br><span class="line">	_Destroy(_S, end());</span><br><span class="line">	_Last = _S;</span><br><span class="line">	return (_F); &#125;</span><br><span class="line">void clear()</span><br><span class="line">	&#123;erase(begin(), end()); &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">void _Destroy(iterator _F, iterator _L)</span><br><span class="line">	&#123;for (; _F != _L; ++_F)</span><br><span class="line">		allocator.destroy(_F); &#125;</span><br><span class="line">iterator _Ucopy(const_iterator _F, const_iterator _L,</span><br><span class="line">	iterator _P)</span><br><span class="line">	&#123;for (; _F != _L; ++_P, ++_F)</span><br><span class="line">		allocator.construct(_P, *_F);</span><br><span class="line">	return (_P); &#125;</span><br><span class="line">void _Ufill(iterator _F, size_type _N, const _Ty &amp;_X)</span><br><span class="line">	&#123;for (; 0 &lt; _N; --_N, ++_F)</span><br><span class="line">		allocator.construct(_F, _X); &#125;</span><br><span class="line">void _Xran() const</span><br><span class="line">	&#123;_THROW(out_of_range, "invalid vector&lt;T&gt; subscript"); &#125;</span><br><span class="line"></span><br><span class="line">size_type capacity() const //容量</span><br><span class="line">&#123;return (_First == 0 ? 0 : _End - _First); &#125;</span><br></pre></td></tr></table></figure>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/10/stl_traits/">
  <time datetime="2016-08-10T04:56:46.000Z">
    2016-08-10
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/10/stl_traits/">STL  traits</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="STL-traits的实现"><a href="#STL-traits的实现" class="headerlink" title="STL traits的实现"></a>STL traits的实现</h1><pre><code>traits 是一种能获取出你所需类型特性的方法：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> output_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> forward_iterator_tag :<span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> bidirectional_iterator_tag: <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> random_access_iterator_tag: <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Cat,<span class="keyword">class</span> _T,<span class="keyword">class</span> _Dis = <span class="keyword">int</span>,</span><br><span class="line">         <span class="keyword">class</span> _P = _T*, <span class="keyword">class</span> _Ref = _T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _Cat iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> _T   value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Dis difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> _P   pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T         value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span>       difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T *       pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T &amp;       reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T               value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span>             difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T *       pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T &amp;       reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span><br><span class="line"><span class="title">iterator_category</span><span class="params">(Iterator &amp;)</span>			      <span class="comment">//迭代器的'类型'</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;</span><br><span class="line">	<span class="keyword">return</span> iterator_category();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span><br><span class="line"><span class="title">value_type</span><span class="params">(Iterator &amp;)</span>                       <span class="comment">//迭代器所指之物类型</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type *</span><br><span class="line"><span class="title">difference_type</span><span class="params">(Iterator &amp;)</span>                 <span class="comment">//获取差值类型</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h1><p><img src="/imgs/Summary/stl_iterator.png" alt="stl_iterator"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> output_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> forward_iterator_tag :<span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> bidirectional_iterator_tag: <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> random_access_iterator_tag: <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="advance例子"><a href="#advance例子" class="headerlink" title="advance例子"></a>advance例子</h1><p><img src="/imgs/Summary/stl_traits.png" alt="stl_traits"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/06/stdarg/">
  <time datetime="2016-08-06T06:33:58.000Z">
    2016-08-06
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/06/stdarg/">可变参函数</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p><img src="/imgs/Summary/stdargs.png" alt="stdargs"></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h2><pre><code>va_list 是一个字符指针类型。
typedef char *va_list; 
</code></pre><h2 id="va-start"><a href="#va-start" class="headerlink" title="va_start"></a>va_start</h2><p>va_start用于初始化 va_list, 取第一个参数(从左向右)的地址再向高地址偏移LASTARG大小，实际上指向了第二个参数(从左向右)</p>
<pre><code>#ifndef __sparc__
#define va_start(AP, LASTARG) \
(AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG))) //AP即va_list

#else
#define va_start(AP, LASTARG) \
(__builtin_saveregs (), \
AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))
#endif

__builtin_saveregs()是在gcc 的库程序libgcc2.c 中定义的，用于保存寄存器。
它的说明可参见gcc 手册章节“Target Description Macros”中的
“Implementing the Varargs Macros”小节。
</code></pre><h3 id="va-rounded-size"><a href="#va-rounded-size" class="headerlink" title="__va_rounded_size"></a>__va_rounded_size</h3><p>__va_rounded_size定义了取整后的TYPE 类型的字节长度值。是int 长度(4)的倍数。</p>
<pre><code>#define __va_rounded_size(TYPE) \
(((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))
</code></pre><h2 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg"></a>va_arg</h2><p>va_arg先让AP偏移到指向下一个参数的位置，再返回要取的参数</p>
<pre><code>#define va_arg(AP, TYPE) \
(AP += __va_rounded_size (TYPE), \
*((TYPE *) (AP - __va_rounded_size (TYPE))))
</code></pre><h2 id="va-end"><a href="#va-end" class="headerlink" title="va_end"></a>va_end</h2><p>va_end 必须在va_arg 读完所有的参数后再被调用。<br>va_end 可以修改AP 使其在重新调用va_start 之前不能被使用(把va_list指向NULL)。<br>    void va_end (va_list);    // 在gnulib 中定义</p>
<pre><code>#define va_end(AP)
</code></pre><h1 id="Linux内核代码Acenv-h中也定义了一组宏"><a href="#Linux内核代码Acenv-h中也定义了一组宏" class="headerlink" title="Linux内核代码Acenv.h中也定义了一组宏"></a>Linux内核代码Acenv.h中也定义了一组宏</h1><p><img src="/imgs/Summary/linux_args.png" alt="linuxstdargs"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">wanyaoqi</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>