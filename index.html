<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Yaoqi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="wanyaoqi">
  
  
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Yaoqi's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yaoqi's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yaoqi's Blog">
<meta name="twitter:description">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Yaoqi&#39;s Blog</a></h1>
    <p><a href="/">coding</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/about">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/11/19/python装饰器/">
  <time datetime="2017-11-19T14:46:38.000Z">
    2017-11-19
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/11/19/python装饰器/">python</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test(func):</span><br><span class="line">	def wrapper():</span><br><span class="line">	    func()</span><br><span class="line">        print func.__name__, "test wrapper"</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@test</span><br><span class="line">def main()</span><br><span class="line">    print "start main"</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">print main.__name__</span><br></pre></td></tr></table></figure>
<p>得到的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">main test wrapper</span><br><span class="line">wrapper</span><br></pre></td></tr></table></figure></p>
<p>可以看到装饰器会改变函数的属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> main</span><br><span class="line">&lt;function wrapper at <span class="number">0x7f79c2437938</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时执行main函数已经被装饰器test返回的wrapper函数给替代了<br>即 main() == test()()<br>再看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(test_arg)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> test_arg</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">	    <span class="keyword">print</span> <span class="string">"inner_wrapper"</span></span><br><span class="line">	    <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">()</span>:</span></span><br><span class="line">	        func()</span><br><span class="line">            <span class="keyword">print</span> func.__name__, <span class="string">"test wrapper"</span></span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p>这时使用装饰器test必须给参数, 如果不给的话test_arg相当与main函数的地址,<br>此时调用wrapper会报错(原因是参数不够)。<br>如果去了wrapper函数的参数则inner_wrapper不会被调用<br>可以看出带参数的装饰器其实包装了一层外壳，先执行最外层test函数的内容，<br>然后将调用的函数的地址传入里层的装饰器</p>
<p>还有一个问题就是之前代码中的func.<strong>name</strong>和main.<strong>name</strong>的问题，<br>不难看出其实main函数的地址就是wrapper的地址，所以main.<strong>name</strong>打印的是wrapper函数的名字，<br>那么如何获得main函数真正的属性呢？</p>
<h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">	    func()</span><br><span class="line">        <span class="keyword">print</span> func.__name__, <span class="string">"test wrapper"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>加上functools.wraps装饰器后的打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">main test wrapper</span><br><span class="line">main</span><br></pre></td></tr></table></figure></p>
<p>进入functools中看warps函数的实现其实可以看到<br>functools.wraps函数将wrapper函数的属性使用setattr设置为传入的func即main函数的属性</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/20/stl_deque_2/">
  <time datetime="2016-08-20T02:52:35.000Z">
    2016-08-20
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/20/stl_deque_2/">STL deque——part 2</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push pop"></a>push pop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在deque末尾添加元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;   </span><br><span class="line">      <span class="comment">// 当前缓冲区还有空间  </span></span><br><span class="line">      construct(finish.cur, t); <span class="comment">// 直接在可用空间构建  </span></span><br><span class="line">      ++finish.cur; <span class="comment">// 调整finish迭代器  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 当前缓冲区无可用空间（last不能存储元素用）  </span></span><br><span class="line">      push_back_aux(t);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在deque头添加元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;     <span class="comment">// 当前缓冲区还有空间  </span></span><br><span class="line">      construct(start.cur - <span class="number">1</span>, t);   </span><br><span class="line">      --start.cur;        </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 当前缓冲区无空间可用了  </span></span><br><span class="line">      push_front_aux(t);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删掉末尾元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;<span class="comment">//最后一个缓冲区（finish指的缓冲区）有多于一个元素（含一个）  </span></span><br><span class="line">      --finish.cur;       </span><br><span class="line">      destroy(finish.cur);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      <span class="comment">// 最后一个缓冲区无元素  </span></span><br><span class="line">      pop_back_aux();       <span class="comment">// 这里会进行缓冲区的释放工作  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在deque头删除元素  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;  </span><br><span class="line">      <span class="comment">// start.node所指缓冲区有多余一个元素（不含一个）  </span></span><br><span class="line">      destroy(start.cur);     </span><br><span class="line">      ++start.cur;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">      <span class="comment">// start.node所指缓冲区只有一个元素  </span></span><br><span class="line">      pop_front_aux();      <span class="comment">// 这里会进行缓冲区释放工作  </span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_back_aux(<span class="keyword">const</span> value_type&amp; t) &#123;  </span><br><span class="line">  value_type t_copy = t;  </span><br><span class="line">  reserve_map_at_back();        <span class="comment">//  若符合某重条件则必须重换一个map  </span></span><br><span class="line">  *(finish.node + <span class="number">1</span>) = allocate_node(); <span class="comment">// 配置一个新结点（缓冲区）  </span></span><br><span class="line">  __STL_TRY &#123;  </span><br><span class="line">    construct(finish.cur, t_copy);      <span class="comment">// 设置值  </span></span><br><span class="line">    finish.set_node(finish.node + <span class="number">1</span>);   <span class="comment">// 改变finish，令其指向新结点  </span></span><br><span class="line">    finish.cur = finish.first;          <span class="comment">// 设置 finish 的状态  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 只有当start.cur == start.first才会调用。  </span></span><br><span class="line"><span class="comment">// 第一个缓冲区没有未用空间时才会调用。和上面实现类似  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_front_aux(<span class="keyword">const</span> value_type&amp; t) &#123;  </span><br><span class="line">  value_type t_copy = t;  </span><br><span class="line">  reserve_map_at_front();         </span><br><span class="line">  *(start.node - <span class="number">1</span>) = allocate_node();    </span><br><span class="line">  __STL_TRY &#123;  </span><br><span class="line">    start.set_node(start.node - <span class="number">1</span>);       </span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;           </span><br><span class="line">    construct(start.cur, t_copy);         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只有当finish.cur == finish.first才会调用  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::pop_back_aux() &#123;  </span><br><span class="line">  deallocate_node(finish.first);      </span><br><span class="line">  finish.set_node(finish.node - <span class="number">1</span>);   </span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;       </span><br><span class="line">  destroy(finish.cur);        </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 只有当start.cur == start.last - 1时才会调用  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::pop_front_aux() &#123;  </span><br><span class="line">  destroy(start.cur);                 </span><br><span class="line">  deallocate_node(start.first);   </span><br><span class="line">  start.set_node(start.node + <span class="number">1</span>);  </span><br><span class="line">  start.cur = start.first;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在map尾添加缓冲区  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>))  </span><br><span class="line">    <span class="comment">//map空间不够用，则开辟新的map空间，把原来map内容拷贝过来。释放原来的  </span></span><br><span class="line">      reallocate_map(nodes_to_add, <span class="literal">false</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在map头添加缓冲区  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)  </span><br><span class="line">      reallocate_map(nodes_to_add, <span class="literal">true</span>);     </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//添加map结点，指向新的缓冲区，add_at_front=true添加在map头，否则添加在尾  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::reallocate_map(size_type nodes_to_add,  </span><br><span class="line">                                              <span class="keyword">bool</span> add_at_front) &#123;  </span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;  </span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;  </span><br><span class="line">  </span><br><span class="line">  map_pointer new_nstart;  </span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;  </span><br><span class="line">    new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span>   </span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)  </span><br><span class="line">      copy(start.node, finish.node + <span class="number">1</span>, new_nstart);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">    size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">// 配置新的结点，准备给map使用  </span></span><br><span class="line">    map_pointer new_map = map_allocator::allocate(new_map_size);  </span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span>  </span><br><span class="line">                         + (add_at_front ? nodes_to_add : <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">// 把原map 內容拷贝  </span></span><br><span class="line">    copy(start.node, finish.node + <span class="number">1</span>, new_nstart);  </span><br><span class="line">    <span class="comment">// 释放放原map  </span></span><br><span class="line">    map_allocator::deallocate(<span class="built_in">map</span>, map_size);  </span><br><span class="line">    <span class="comment">// 设置新map起始位置和大小  </span></span><br><span class="line">    <span class="built_in">map</span> = new_map;  </span><br><span class="line">    map_size = new_map_size;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新设置迭代器 start 和 finish  </span></span><br><span class="line">  start.set_node(new_nstart);  </span><br><span class="line">  finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line"># insert</span><br><span class="line">  </span><br><span class="line">```cpp    </span><br><span class="line">  <span class="comment">// 在position 处插入一個元素，其值为 x  </span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;      <span class="comment">// position是deque的最前端，则调用push_front()</span></span><br><span class="line">      push_front(x);      </span><br><span class="line">      <span class="keyword">return</span> start;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;   <span class="comment">// position是deque的最末端，则调用push_back()</span></span><br><span class="line">      push_back(x);  </span><br><span class="line">      iterator tmp = finish;  </span><br><span class="line">      --tmp;  </span><br><span class="line">      <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> insert_aux(position, x);       <span class="comment">// 都不是就交给insert_aux 去做  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//在pos处插入一个元素，值为x。要判断插入点距头更近还是尾更近</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;  </span><br><span class="line">  difference_type index = pos - start;    </span><br><span class="line">  value_type x_copy = x;  </span><br><span class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;    <span class="comment">//插入点之前的元素少</span></span><br><span class="line">    push_front(front());          </span><br><span class="line">    iterator front1 = start;  </span><br><span class="line">    ++front1;  </span><br><span class="line">    iterator front2 = front1;  </span><br><span class="line">    ++front2;  </span><br><span class="line">    pos = start + index;  </span><br><span class="line">    iterator pos1 = pos;  </span><br><span class="line">    ++pos1;  </span><br><span class="line">    copy(front2, pos1, front1);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;                      <span class="comment">//插入点之后的元素少</span></span><br><span class="line">    push_back(back());        </span><br><span class="line">    iterator back1 = finish;  </span><br><span class="line">    --back1;  </span><br><span class="line">    iterator back2 = back1;  </span><br><span class="line">    --back2;  </span><br><span class="line">    pos = start + index;  </span><br><span class="line">    copy_backward(pos, back2, back1);     </span><br><span class="line">  &#125;  </span><br><span class="line">  *pos = x_copy;      </span><br><span class="line">  <span class="keyword">return</span> pos;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整deque的大小。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; len)   <span class="comment">//如果deque变小，直接擦除掉多余的元素</span></span><br><span class="line">      erase(start + new_size, finish);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      insert(finish, new_size - len, x);  <span class="comment">//如果deque变大，则在deque后面插入元素补充</span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; resize(new_size, value_type()); &#125;  </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">## erase</span><br><span class="line">```cpp                          </span><br><span class="line">  <span class="comment">// 清除 pos 所指的元素。  </span></span><br><span class="line">  <span class="comment">//判断pos距离头近还是距离尾近，距离那个位置近就移动那个位置的元素，保证移动元素个数最少  </span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;  </span><br><span class="line">    iterator next = pos;  </span><br><span class="line">    ++next;  </span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// pos和deque开头元素的个数  </span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>)) &#123;           <span class="comment">// size() &gt;&gt; 1为size()/2  </span></span><br><span class="line">    <span class="comment">//如果pos距离deque头比较近的话，deque的开头到pos元素向后移  </span></span><br><span class="line">      copy_backward(start, pos, next);    </span><br><span class="line">      pop_front();              <span class="comment">// 移动后，删除第一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;                  <span class="comment">// 否则pos+1到结尾元素向前移，  </span></span><br><span class="line">      copy(next, finish, pos);    </span><br><span class="line">      pop_back();                 </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> start + index;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//擦除两个迭代器之间的元素  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::iterator   </span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123; <span class="comment">// 如果是清除整个 deque  </span></span><br><span class="line">    clear();                            <span class="comment">// 直接调用 clear() 即可  </span></span><br><span class="line">    <span class="keyword">return</span> finish;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> &#123;  </span><br><span class="line">    difference_type n = last - first;           <span class="comment">// 擦除区间长度  </span></span><br><span class="line">    difference_type elems_before = first - start;   <span class="comment">// 擦除区间前方元素的个数  </span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;       <span class="comment">// 如果前方的元素少，  </span></span><br><span class="line">      copy_backward(start, first, last);        <span class="comment">// 前方元素向后移（覆盖擦除区间）  </span></span><br><span class="line">      iterator new_start = start + n;           <span class="comment">// deque 的新起点  </span></span><br><span class="line">      destroy(start, new_start);                <span class="comment">// 多于元素析构  </span></span><br><span class="line">      <span class="comment">// 释放多于元素所占内存  </span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)  </span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  </span><br><span class="line">      start = new_start;      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 后方元素更少  </span></span><br><span class="line">      copy(last, finish, first);    <span class="comment">//后方元素向前移动（覆盖擦除区间）     </span></span><br><span class="line">      iterator new_finish = finish - n;   </span><br><span class="line">      destroy(new_finish, finish);        </span><br><span class="line">      <span class="comment">// 释放多于元素所占内存</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)  </span><br><span class="line">        data_allocator::deallocate(*cur, buffer_size());  </span><br><span class="line">      finish = new_finish;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> start + elems_before;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空deque。最后保留了一个缓冲区，这是deque的策略，也是其初始状态  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::clear() &#123;  </span><br><span class="line">  <span class="comment">//头尾以外的缓冲区，它们肯定是满的。  </span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;  </span><br><span class="line"></span><br><span class="line">    destroy(*node, *node + buffer_size());  </span><br><span class="line">    data_allocator::deallocate(*node, buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123;  <span class="comment">// 至少有2个以上（含）缓冲区  </span></span><br><span class="line">    destroy(start.cur, start.last); <span class="comment">// 头缓冲区元素析构  </span></span><br><span class="line">    destroy(finish.first, finish.cur); <span class="comment">// 尾缓冲区元素析构  </span></span><br><span class="line">    <span class="comment">// 释放尾缓冲区，保留了头缓冲区  </span></span><br><span class="line">    data_allocator::deallocate(finish.first, buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 只有一个缓冲区  </span></span><br><span class="line">    destroy(start.cur, finish.cur); <span class="comment">// 析构，但是不释放  </span></span><br><span class="line">  </span><br><span class="line">  finish = start;   <span class="comment">// 调整迭代器，deque为空  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/18/stl_deque_1/">
  <time datetime="2016-08-18T13:59:56.000Z">
    2016-08-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/18/stl_deque_1/">STL deque——part 1</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h1><p>deque是一个双端队列<br><img src="/imgs/stl_deque/deque_1.png" alt="1"><br><img src="/imgs/stl_deque/deque_2.png" alt="2"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;   </span><br><span class="line"><span class="keyword">class</span> <span class="built_in">deque</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  ···</span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members  </span></span><br><span class="line">  iterator start;       <span class="comment">// start.cur指向deque的第一个结点  </span></span><br><span class="line">  iterator finish;  <span class="comment">// finish.cur指向迭代器deque的最后一个结点的后一个元素  </span></span><br><span class="line">  </span><br><span class="line">  map_pointer <span class="built_in">map</span>;  <span class="comment">// 指向中控器。其实是指向中控器的第一个结点。  </span></span><br><span class="line">                    <span class="comment">//  中控器是连续的，map_size定义了中控器的大小。  </span></span><br><span class="line">                           </span><br><span class="line">  size_type map_size;   <span class="comment">// 中控器的大小。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/imgs/stl_deque/deque_3.png" alt="3"></p>
<h1 id="deque-迭代器"><a href="#deque-迭代器" class="headerlink" title="deque 迭代器"></a>deque 迭代器</h1><p><img src="/imgs/stl_deque/deque_4.png" alt="4"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">此函数用来计算缓冲区的大小 </span><br><span class="line">如果n不等于0，那么返回n，开发者自己决定 </span><br><span class="line">    否则：如果sz小于512，返回512/sz </span><br><span class="line">    	如果sz大于512，返回1 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//deque的迭代器，未继承std::iterator  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr, <span class="keyword">size_t</span> BufSiz&gt;  </span><br><span class="line"><span class="keyword">struct</span> __deque_iterator &#123;     </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;      iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//没有继承std::iterator，自己定义5个迭代器相应型别。  </span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)  </span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                 <span class="comment">// (2)  </span></span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;              <span class="comment">// (3)  </span></span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                <span class="comment">// (4)  </span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;    <span class="comment">// (5)  </span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;  <span class="comment">//注意，是指针的指针  </span></span><br><span class="line">  <span class="comment">//map_pointer指向中控器，中控器的存储的是指针，指向node-buf结点缓冲区  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  T* cur;   <span class="comment">// 迭代器所指元素  </span></span><br><span class="line">  T* first; <span class="comment">// 迭代器所指元素所在缓冲区的开头  </span></span><br><span class="line">  T* last;  <span class="comment">// 迭代器所指元素所在缓冲区的结尾（结尾包含在缓冲区内）  </span></span><br><span class="line">  map_pointer node;<span class="comment">//指向中控器的结点，这个结点指向迭代器所指元素所在的缓冲区  </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//迭代器的构造函数  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//x是迭代器所指结点，y为中控器中的结点的值，指向x所指缓冲区  </span></span><br><span class="line">  __deque_iterator(T* x, map_pointer y)   </span><br><span class="line">    : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125;  </span><br><span class="line">    <span class="comment">//默认构造函数  </span></span><br><span class="line">  __deque_iterator() : cur(<span class="number">0</span>), first(<span class="number">0</span>), last(<span class="number">0</span>), node(<span class="number">0</span>) &#123;&#125;  </span><br><span class="line">    <span class="comment">//用一个迭代器x初始化本迭代器  </span></span><br><span class="line">  __deque_iterator(<span class="keyword">const</span> iterator&amp; x)  </span><br><span class="line">    : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器需要重载的运算符  </span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;   </span><br><span class="line"><span class="comment">/* </span><br><span class="line">两个迭代器之间的距离。这两个迭代器可能不在同一个buffer上。 </span><br><span class="line">*/</span>  </span><br><span class="line">  difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +  </span><br><span class="line">      (cur - first) + (x.last - x.cur);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* </span><br><span class="line">    迭代器前进一步。 </span><br><span class="line">    先++cur，再判断cur==last。说明cur不会指向last的。last所指空间不存内容 </span><br><span class="line">  */</span>  </span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;  </span><br><span class="line">    ++cur;              <span class="comment">// 前进一步  </span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;      <span class="comment">// 到了所在缓冲区的尾端了  </span></span><br><span class="line">      set_node(node + <span class="number">1</span>);   <span class="comment">// 切换到下一个缓冲区  </span></span><br><span class="line">      cur = first;          <span class="comment">//   的第一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   </span><br><span class="line">  &#125;  </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    ++*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//迭代器往回走一步。  </span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;  </span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123; <span class="comment">// 如果在所在缓冲区的头部  </span></span><br><span class="line">      set_node(node - <span class="number">1</span>);   <span class="comment">// 切换到前一个缓冲区  </span></span><br><span class="line">      cur = last;           <span class="comment">//   的最后一个元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    --cur;              <span class="comment">// 直接往回走一步  </span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    --*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* </span><br><span class="line">    迭代器向前进或后退n步（取决于n的正负）。这是支持random access iterator 所必须的操作。 </span><br><span class="line">    如果这个操作不会是迭代器走出当前所在缓冲区，直接更改cur即可。 </span><br><span class="line">    如果这个操作使迭代器走出当前所在缓冲区，要计算出操作后在哪个缓冲区的哪个位置。 </span><br><span class="line">  */</span>  </span><br><span class="line">  self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;  </span><br><span class="line">    difference_type offset = n + (cur - first);  </span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))  </span><br><span class="line">      <span class="comment">// 不会走出当前所在缓冲区  </span></span><br><span class="line">      cur += n;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="comment">// 走出了当前所在缓冲区  </span></span><br><span class="line">      difference_type node_offset =  </span><br><span class="line">        offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())  </span><br><span class="line">                   : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;  </span><br><span class="line">      <span class="comment">// 切换缓冲区  </span></span><br><span class="line">      set_node(node + node_offset);  </span><br><span class="line">      <span class="comment">// 找到切换缓冲区后，迭代器所指向的元素  </span></span><br><span class="line">      cur = first + (offset - node_offset * difference_type(buffer_size()));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="comment">//调用operator+=  </span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;  </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">  <span class="comment">// 以上调用了operator*, operator+  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*迭代器关于比较的运算符的重载*/</span>  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//切换缓冲区，更改了first和last，但是未更改cur  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;  </span><br><span class="line">    node = new_node;  </span><br><span class="line">    first = *new_node;  </span><br><span class="line">    last = first + difference_type(buffer_size());  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/imgs/stl_deque/deque_5.png" alt="5"></p>
<h1 id="deque的定义"><a href="#deque的定义" class="headerlink" title="deque的定义"></a>deque的定义</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;   </span><br><span class="line">class deque &#123;  </span><br><span class="line">public:                         // Basic types  </span><br><span class="line">  typedef T value_type;  </span><br><span class="line">  typedef value_type* pointer;  </span><br><span class="line">  typedef const value_type* const_pointer;  </span><br><span class="line">  typedef value_type&amp; reference;  </span><br><span class="line">  typedef const value_type&amp; const_reference;  </span><br><span class="line">  typedef size_t size_type;  </span><br><span class="line">  typedef ptrdiff_t difference_type;  </span><br><span class="line">  </span><br><span class="line">public:                         // 迭代器  </span><br><span class="line">  typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;              iterator;  </span><br><span class="line">  typedef __deque_iterator&lt;T, const T&amp;, const T&amp;, BufSiz&gt;  const_iterator;  </span><br><span class="line"></span><br><span class="line">  typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  </span><br><span class="line">  typedef reverse_iterator&lt;iterator&gt; reverse_iterator;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">protected:                      // Internal typedefs  </span><br><span class="line">  // 指向中控器，是指针的指针（pointer of pointer of T）  </span><br><span class="line">  typedef pointer* map_pointer;   </span><br><span class="line">  // 空间配置器，用来配置缓冲区  </span><br><span class="line">  typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  </span><br><span class="line">  // 空间配置器，用来配置中控器  </span><br><span class="line">  typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator;  </span><br><span class="line">  </span><br><span class="line">  static size_type buffer_size() &#123;  </span><br><span class="line">    return __deque_buf_size(BufSiz, sizeof(value_type));  </span><br><span class="line">  &#125;  </span><br><span class="line">  //默认中控器大小为8  </span><br><span class="line">  static size_type initial_map_size() &#123; return 8; &#125;  </span><br><span class="line">  </span><br><span class="line">protected:                      // Data members  </span><br><span class="line">  iterator start;       // start.cur指向deque的第一个结点  </span><br><span class="line">  iterator finish;  // finish.cur指向迭代器deque的最后一个结点的后一个元素  </span><br><span class="line">  </span><br><span class="line">  map_pointer map;  // 指向中控器。其实是指向中控器的第一个结点。  </span><br><span class="line">                    //  中控器是连续的，map_size定义了中控器的大小。  </span><br><span class="line">                           </span><br><span class="line">  size_type map_size;   // 中控器的大小。  </span><br><span class="line">  </span><br><span class="line">public:                         // 对外的接口  </span><br><span class="line">  iterator begin() &#123; return start; &#125;  </span><br><span class="line">  iterator end() &#123; return finish; &#125;  </span><br><span class="line">  const_iterator begin() const &#123; return start; &#125;  </span><br><span class="line">  const_iterator end() const &#123; return finish; &#125;  </span><br><span class="line">  </span><br><span class="line">  reverse_iterator rbegin() &#123; return reverse_iterator(finish); &#125;  </span><br><span class="line">  reverse_iterator rend() &#123; return reverse_iterator(start); &#125;  </span><br><span class="line">  const_reverse_iterator rbegin() const &#123;  </span><br><span class="line">    return const_reverse_iterator(finish);  </span><br><span class="line">  &#125;  </span><br><span class="line">  const_reverse_iterator rend() const &#123;  </span><br><span class="line">    return const_reverse_iterator(start);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference operator[](size_type n) &#123;  </span><br><span class="line">    return start[difference_type(n)]; // 调用 __deque_iterator&lt;&gt;::operator[]  </span><br><span class="line">  &#125;  </span><br><span class="line">  const_reference operator[](size_type n) const &#123;  </span><br><span class="line">    return start[difference_type(n)];  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  reference front() &#123; return *start; &#125; // 调用 __deque_iterator&lt;&gt;::operator*  </span><br><span class="line">    </span><br><span class="line">  //取出最后一个元素  </span><br><span class="line">  reference back() &#123;  </span><br><span class="line">    iterator tmp = finish;    </span><br><span class="line">    --tmp;  // 调用 __deque_iterator&lt;&gt;::operator--  </span><br><span class="line">    return *tmp;    // 调用 __deque_iterator&lt;&gt;::operator*  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  //返回第一个元素，并不删除  </span><br><span class="line">  const_reference front() const &#123; return *start; &#125;  </span><br><span class="line">  const_reference back() const &#123;  </span><br><span class="line">    const_iterator tmp = finish;  </span><br><span class="line">    --tmp;  </span><br><span class="line">    return *tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  //两分号但是合法</span><br><span class="line">  size_type size() const &#123; return finish - start;; &#125;   </span><br><span class="line">    //deque最大容量。  </span><br><span class="line">  size_type max_size() const &#123; return size_type(-1); &#125;  </span><br><span class="line">  //下面调用了operator::iterator==  </span><br><span class="line">  bool empty() const &#123; return finish == start; &#125;  </span><br><span class="line">  </span><br><span class="line">public:       </span><br><span class="line">    </span><br><span class="line">   //默认构造函数  </span><br><span class="line">  deque(): start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    create_map_and_nodes(0);  </span><br><span class="line">  &#125;  </span><br><span class="line">//用一个deque构建新的deque  </span><br><span class="line">  deque(const deque&amp; x)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    create_map_and_nodes(x.size());  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      uninitialized_copy(x.begin(), x.end(), start);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //commit or rollback  </span><br><span class="line">    __STL_UNWIND(destroy_map_and_nodes());  </span><br><span class="line">  &#125;  </span><br><span class="line">//构建大小为n，元素值为value的deque  </span><br><span class="line">  deque(size_type n, const value_type&amp; value)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  deque(int n, const value_type&amp; value)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  deque(long n, const value_type&amp; value)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value);  </span><br><span class="line">  &#125;  </span><br><span class="line">//构建大小为n的deque，默认值为T(),说明deque容器的元素要有默认构造函数  </span><br><span class="line">  explicit deque(size_type n)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    fill_initialize(n, value_type());  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  template &lt;class InputIterator&gt;  </span><br><span class="line">  deque(InputIterator first, InputIterator last)  </span><br><span class="line">    : start(), finish(), map(0), map_size(0)  </span><br><span class="line">  &#123;  </span><br><span class="line">    range_initialize(first, last, iterator_category(first));  </span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  ~deque() &#123;  </span><br><span class="line">    destroy(start, finish);  </span><br><span class="line">    destroy_map_and_nodes();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  deque&amp; operator= (const deque&amp; x) &#123;  </span><br><span class="line">    const size_type len = size();  </span><br><span class="line">    if (&amp;x != this) &#123;  </span><br><span class="line">      if (len &gt;= x.size())  </span><br><span class="line">        erase(copy(x.begin(), x.end(), start), finish);  </span><br><span class="line">      else &#123;  </span><br><span class="line">        const_iterator mid = x.begin() + difference_type(len);  </span><br><span class="line">        copy(x.begin(), mid, start);  </span><br><span class="line">        insert(finish, mid, x.end());  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return *this;  </span><br><span class="line">  &#125;          </span><br><span class="line">  </span><br><span class="line">  void swap(deque&amp; x) &#123;  </span><br><span class="line">    __STD::swap(start, x.start);  </span><br><span class="line">    __STD::swap(finish, x.finish);  </span><br><span class="line">    __STD::swap(map, x.map);  </span><br><span class="line">    __STD::swap(map_size, x.map_size);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/18/stl_list_2/">
  <time datetime="2016-08-17T16:31:32.000Z">
    2016-08-18
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/18/stl_list_2/">STL list ——part 2</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="transfer、splice"><a href="#transfer、splice" class="headerlink" title="transfer、splice"></a>transfer、splice</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将first到last內的所有元素搬移到position 前，不包括last元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (position != last) &#123;  </span><br><span class="line"></span><br><span class="line">    (*(link_type((*last.node).prev))).next = position.node;          </span><br><span class="line">    (*(link_type((*first.node).prev))).next = last.node;       </span><br><span class="line">    (*(link_type((*position.node).prev))).next = first.node; </span><br><span class="line">        </span><br><span class="line">    link_type tmp = link_type((*position.node).prev);        </span><br><span class="line">    (*position.node).prev = (*last.node).prev;                </span><br><span class="line">    (*last.node).prev = (*first.node).prev;                  </span><br><span class="line">    (*first.node).prev = tmp;                            </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁移过程如图：<br><img src="/imgs/stl_list/transfer.png" alt="transfer"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 x 链表插入到 position 所指位置之前。x 必须不能是 *this。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span><br><span class="line"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (!x.empty())   </span><br><span class="line">    transfer(position, x.begin(), x.end());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 將i所指元素插入到 position 所指位置之前。position 和i 可在同一个list。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span></span><br><span class="line"></span>&#123;  </span><br><span class="line">  iterator j = i;  </span><br><span class="line">  ++j;  </span><br><span class="line">  <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;  </span><br><span class="line">  transfer(position, i, j);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 將 [first,last) 內的所有元素插入到 position 所指位置之前。  </span></span><br><span class="line"><span class="comment">// position 和[first,last)可指在同一个list，  </span></span><br><span class="line"><span class="comment">// 但position不能位于[first,last)之內。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator first, iterator last)</span></span><br><span class="line"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (first != last)   </span><br><span class="line">    transfer(position, first, last);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将x合并到*this上面。两个链表都要先经过递增排序。相当于合并排序的最后一步  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span><br><span class="line">&#123;  </span><br><span class="line">  iterator first1 = begin();  </span><br><span class="line">  iterator last1 = end();  </span><br><span class="line">  iterator first2 = x.begin();  </span><br><span class="line">  iterator last2 = x.end();  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//前提是两个链表都已经递增排序好了  </span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">      iterator next = first2;  </span><br><span class="line">      transfer(first1, first2, ++next);  </span><br><span class="line">      first2 = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      ++first1;  </span><br><span class="line">  <span class="keyword">if</span> (first2 != last2) transfer(last1, first2, last2);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将 list逆置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::reverse() </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//如果链表是空，或者只有一个元素，就不做任何处理  </span></span><br><span class="line">    <span class="comment">//不是用size()==0或size()==1来判断，因为这样比较慢  </span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  ++first;  </span><br><span class="line">  <span class="keyword">while</span> (first != end()) &#123;  </span><br><span class="line">    iterator old = first;  </span><br><span class="line">    ++first;  </span><br><span class="line">    transfer(begin(), old, first);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="list-sort"><a href="#list-sort" class="headerlink" title="list sort"></a>list sort</h1><p>list不能采用STL sort()算法，必须使用自己的sort；因为STL sort只能接收随机流迭代器<br>SGI实现版：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::sort() &#123;  </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; carry;  </span><br><span class="line">  <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fill = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">while</span> (!empty()) </span><br><span class="line">  &#123;  </span><br><span class="line">    carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());  <span class="comment">//取第一个放入carry中</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())	     <span class="comment">//counter[i]为空则跳过</span></span><br><span class="line">    &#123;      </span><br><span class="line">      counter[i].merge(carry);                   <span class="comment">//有序的合并到counter</span></span><br><span class="line">      carry.swap(counter[i++]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    carry.swap(counter[i]);           <span class="comment">//将carry中的数据交换到counter[i]中</span></span><br><span class="line">    <span class="keyword">if</span> (i == fill) ++fill;  </span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i)       <span class="comment">//将数组中所有的数据合并到最后一个桶中</span></span><br><span class="line">     counter[i].merge(counter[i<span class="number">-1</span>]);  </span><br><span class="line">  swap(counter[fill<span class="number">-1</span>]);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//两个链表交换，就是他们的node头结点交换 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	__STD::swap(node, x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sort的过程是一个循环归并的过程，定义一个tmp和一个list数组</p>
<pre><code>假设有这样以组数: 3 5 1 2 7 6 9    
1.取 3 放入carry中，此时不满足循环条件i==fill，将carry中数据换入counter[0]中，carry为空，counter[0]为{3};
2.取 5 放入carry中，carry与counter[0] merge并交换，得到counter为空，counter[1]为{3，5};
3.取 1 放如carry中,此时counter[0]为空，不进入while循环，将 1 放入 counter[0]中，counter[0]为{1};
4.去 2 放入carry中，和counter[0] merge 后又与counter[1] merge放入counter[2]中，counter[2]为{1，2，3，5}
counter[0]和counter[1]为空；
</code></pre><p>一直循环下去。。直到list为空。<br>然后最后面for循环将counter中的合并到最后一个中，在换给list，即完成了排序；</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/15/stl_list_1/">
  <time datetime="2016-08-15T15:19:53.000Z">
    2016-08-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/15/stl_list_1/">STL list ——part 1</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a>list结构</h1><p>STL list是一个环形双向链表 ，结点结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> __list_node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prev;<span class="comment">//其实可以设为__list_node&lt;T&gt;*</span></span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>list是一个双向链表,其迭代器可以向前移、向后移,因此迭代器类型为bidirectional_iterator_tag<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有继承 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr&gt;  </span><br><span class="line"><span class="keyword">struct</span> __list_iterator &#123;   </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为了支持STL型别标准，自己定义5个类别  </span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;           </span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;          </span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;             </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;   </span><br><span class="line">  </span><br><span class="line">  link_type node;  <span class="comment">// 指向list的结点指针 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造函数  </span></span><br><span class="line">  __list_iterator(link_type x) : node(x) &#123;&#125;  </span><br><span class="line">  __list_iterator() &#123;&#125;  </span><br><span class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器操作运算符重载</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125; </span><br><span class="line">       </span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;      </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR    </span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span>  </span></span><br><span class="line">      </span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;   </span><br><span class="line">    node = (link_type)((*node).next);     </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;    </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    ++*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;      </span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;   </span><br><span class="line">    node = (link_type)((*node).prev);   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">  &#125;    </span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;   </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">    --*<span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="list-定义"><a href="#list-定义" class="headerlink" title="list 定义"></a>list 定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt; <span class="comment">// 默认为 alloc 为配置器  </span></span><br><span class="line"><span class="keyword">class</span> <span class="built_in">list</span> &#123;  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;    </span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;  </span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;  </span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;  </span><br><span class="line">  <span class="keyword">typedef</span> list_node* link_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span>  </span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,  </span><br><span class="line">  const_reference, difference_type&gt;  </span><br><span class="line">  const_reverse_iterator;  </span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,  </span><br><span class="line">  difference_type&gt;  </span><br><span class="line">  reverse_iterator;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  <span class="comment">//申请、释放结点 </span></span><br><span class="line">  <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::allocate(); &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::deallocate(p); &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;  </span><br><span class="line">    link_type p = get_node();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      construct(&amp;p-&gt;data, x);    </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(put_node(p));  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;  </span><br><span class="line">    destroy(&amp;p-&gt;data);       </span><br><span class="line">    put_node(p);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="comment">//初始化一个空链表，首尾相连  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    node = get_node();    </span><br><span class="line">    node-&gt;next = node;     </span><br><span class="line">    node-&gt;prev = node;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//初始化长为n的链表，值都为value  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), n, value);      <span class="comment">//先初始化一个空链表在插入n个结点</span></span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line">  <span class="comment">//以迭代器区间初始化一个链表  </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  <span class="comment">//</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//commit or rollback  </span></span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* __STL_MEMBER_TEMPLATES */</span>  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;  </span><br><span class="line">    empty_initialize();  </span><br><span class="line">    __STL_TRY &#123;  </span><br><span class="line">      insert(begin(), first, last);  </span><br><span class="line">    &#125;  </span><br><span class="line">    __STL_UNWIND(clear(); put_node(node));  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:   </span><br><span class="line">  link_type node; <span class="comment">//头结点  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="list元素操作"><a href="#list元素操作" class="headerlink" title="list元素操作"></a>list元素操作</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>list() { empty_initialize(); // 默认构造函数，空链表。

//构造长为n的链表
list(size_type n, const T&amp; value) { fill_initialize(n, value); } 

list(int n, const T&amp; value) { fill_initialize(n, value); }  

list(long n, const T&amp; value) { fill_initialize(n, value); } 

explicit list(size_type n) { fill_initialize(n, T()); }

//迭代器区间构造list   
template &lt;class InputIterator&gt;  
list(InputIterator first, InputIterator last){range_initialize(first, last);}

//拷贝构造list
list(const list&lt;T, Alloc&gt;&amp; x){range_initialize(x.begin(), x.end());}  
</code></pre><h2 id="push、pop、erase、insert、clear、remove、unique"><a href="#push、pop、erase、insert、clear、remove、unique" class="headerlink" title="push、pop、erase、insert、clear、remove、unique"></a>push、pop、erase、insert、clear、remove、unique</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span><br><span class="line">  </span>&#123; </span><br><span class="line">  	insert(begin(), x); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span><br><span class="line">  </span>&#123; </span><br><span class="line">   	insert(end(), x); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span><br><span class="line">  </span>&#123; </span><br><span class="line">  	erase(begin()); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span><br><span class="line">  </span>&#123;   </span><br><span class="line">    iterator tmp = end();  </span><br><span class="line">    erase(--tmp);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> <span class="comment">//在postition所指位置之前插入一个结点</span></span><br><span class="line">  </span>&#123;  </span><br><span class="line">    link_type tmp = create_node(x); <span class="comment">// 申请一个结点并用x初始化   </span></span><br><span class="line">    tmp-&gt;next = position.node;  </span><br><span class="line">    tmp-&gt;prev = position.node-&gt;prev;  </span><br><span class="line">    <span class="comment">//prev和next指针都是void*，所以需要指针类型转换  </span></span><br><span class="line">    (link_type(position.node-&gt;prev))-&gt;next = tmp;  </span><br><span class="line">    position.node-&gt;prev = tmp;  </span><br><span class="line">    <span class="keyword">return</span> tmp;  </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span>  <span class="comment">//移除position所指结点 </span></span><br><span class="line">  </span>&#123;  </span><br><span class="line">    link_type next_node = link_type(position.node-&gt;next);  </span><br><span class="line">    link_type prev_node = link_type(position.node-&gt;prev);  </span><br><span class="line">    prev_node-&gt;next = next_node;  </span><br><span class="line">    next_node-&gt;prev = prev_node;  </span><br><span class="line">    destroy_node(position.node);  </span><br><span class="line">    <span class="keyword">return</span> iterator(next_node);  </span><br><span class="line">  &#125;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;   </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::clear()    <span class="comment">// 清除所有结点 </span></span><br><span class="line">&#123;  </span><br><span class="line">  link_type cur = (link_type) node-&gt;next; <span class="comment">// begin()  </span></span><br><span class="line">  <span class="keyword">while</span> (cur != node) &#123;   <span class="comment">//遍历结点</span></span><br><span class="line">    link_type tmp = cur;  </span><br><span class="line">    cur = (link_type) cur-&gt;next;  </span><br><span class="line">    destroy_node(tmp);    </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 恢复头结点状态</span></span><br><span class="line">  node-&gt;next = node;  </span><br><span class="line">  node-&gt;prev = node;  </span><br><span class="line">&#125; 	  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::remove(<span class="keyword">const</span> T&amp; value) <span class="comment">// 将数值为value的结点移除</span></span><br><span class="line">&#123;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  iterator last = end();  </span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;    </span><br><span class="line">    iterator next = first;  </span><br><span class="line">    ++next;  </span><br><span class="line">    <span class="keyword">if</span> (*first == value) erase(first);  <span class="comment">// 移除  </span></span><br><span class="line">    first = next;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;  </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::unique()<span class="comment">// 移除数值相同的连续元素 ，只有相同的连续元素才会被移除！！</span></span><br><span class="line">&#123;  </span><br><span class="line">  iterator first = begin();  </span><br><span class="line">  iterator last = end();  </span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;  </span><br><span class="line">  iterator next = first;  </span><br><span class="line">  <span class="keyword">while</span> (++next != last) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (*first == *next)</span><br><span class="line">      erase(next);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      first = next;  </span><br><span class="line">    next = first;    <span class="comment">//调整范围</span></span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span><br><span class="line"></span>&#123;  </span><br><span class="line">    size_type result = <span class="number">0</span>;  </span><br><span class="line">    distance(begin(), end(), result);  <span class="comment">// 在&lt;stl_iterator.h&gt;定义，result是引用传递  </span></span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/14/stl_vector/">
  <time datetime="2016-08-13T17:53:03.000Z">
    2016-08-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/14/stl_vector/">STL vector</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h1><p>   vector 数据安排上和数组非常相似，差别在于数组大小定义后不能在改变而vector内部会自行扩充空间容纳新元素</p>
<h1 id="vector-定义"><a href="#vector-定义" class="headerlink" title="vector 定义"></a>vector 定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty, <span class="keyword">class</span> _A = allocator&lt;_Ty&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;_Ty, _A&gt;     _Myt;</span><br><span class="line">	<span class="keyword">typedef</span> _A                  allocator_type;</span><br><span class="line">	<span class="keyword">typedef</span> _A::size_type       size_type;</span><br><span class="line">	<span class="keyword">typedef</span> _A::difference_type difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> _A::pointer         _Tptr;</span><br><span class="line">	<span class="keyword">typedef</span> _A::const_pointer   _Ctptr;</span><br><span class="line">	<span class="keyword">typedef</span> _A::reference       reference;</span><br><span class="line">	<span class="keyword">typedef</span> _A::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> _A::value_type      value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tptr               iterator;                <span class="comment">//vector迭代器就是本身的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> _Ctptr              const_iterator;</span><br><span class="line">	</span><br><span class="line">protect:	</span><br><span class="line">	_A allocator;                <span class="comment">//空间配置器</span></span><br><span class="line">	iterator _First, _Last, _End;<span class="comment">//正在使用的头，正在使用的尾，空间的尾</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">explicit vector(const _A&amp; _Al = _A())                 //简单的初始化成员变量</span><br><span class="line">	: allocator(_Al), _First(0), _Last(0), _End(0) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">explicit vector(size_type _N, const _Ty&amp; _V = _Ty(),  //初始化_N个_TY变量</span><br><span class="line">	const _A&amp; _Al = _A())</span><br><span class="line">	: allocator(_Al)</span><br><span class="line">	&#123;_First = allocator.allocate(_N, (void *)0);</span><br><span class="line">	_Ufill(_First, _N, _V);                       //这个函数后面会有，就是从_F开始构造_N个_V                   </span><br><span class="line">	_Last = _First + _N;</span><br><span class="line">	_End = _Last; &#125;</span><br><span class="line">	</span><br><span class="line">vector(const _Myt&amp; _X)                           //拷贝构造函数</span><br><span class="line">	: allocator(_X.allocator)</span><br><span class="line">	&#123;_First = allocator.allocate(_X.size(), (void *)0);</span><br><span class="line">	_Last = _Ucopy(_X.begin(), _X.end(), _First);</span><br><span class="line">	_End = _Last; &#125;</span><br><span class="line">	</span><br><span class="line">typedef const_iterator _It;</span><br><span class="line">vector(_It _F, _It _L, const _A&amp; _Al = _A())     //构造vector并在开始位置插入_F到_L间的数据</span><br><span class="line">	: allocator(_Al), _First(0), _Last(0), _End(0)</span><br><span class="line">	&#123;insert(begin(), _F, _L); &#125;</span><br></pre></td></tr></table></figure>
<h1 id="vector-元素操作"><a href="#vector-元素操作" class="headerlink" title="vector 元素操作"></a>vector 元素操作</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line">void resize(size_type _N, const _Ty&amp; _X = _Ty())  //resize手动改变vector容量</span><br><span class="line">	&#123;if (size() &lt; _N)</span><br><span class="line">		insert(end(), _N - size(), _X);</span><br><span class="line">	else if (_N &lt; size())</span><br><span class="line">		erase(begin() + _N, end()); &#125;</span><br><span class="line">size_type size() const //已用大小</span><br><span class="line">	&#123;return (_First == 0 ? 0 : _Last - _First); &#125;</span><br><span class="line"></span><br><span class="line">bool empty() const</span><br><span class="line">	&#123;return (size() == 0); &#125;</span><br><span class="line"></span><br><span class="line">reference operator[](size_type _P)</span><br><span class="line">	&#123;return (*(begin() + _P)); &#125;</span><br><span class="line"></span><br><span class="line">void push_back(const _Ty&amp; _X)     //在容器的最后插入一个元素</span><br><span class="line">	&#123;insert(end(), _X); &#125;</span><br><span class="line">void pop_back()                   //删除最后一个元素</span><br><span class="line">	&#123;erase(end() - 1); &#125;</span><br><span class="line"></span><br><span class="line">iterator insert(iterator _P, const _Ty&amp; _X = _Ty()) //插入一个,返回的迭代器指向的是</span><br><span class="line">	&#123;size_type _O = _P - begin();</span><br><span class="line">	insert(_P, 1, _X);</span><br><span class="line">	return (begin() + _O); &#125;</span><br><span class="line">	</span><br><span class="line">void insert(iterator _P, size_type _M, const _Ty&amp; _X) //从_P开始插入_M个_X元素</span><br><span class="line">	&#123;if (_End - _Last &lt; _M)</span><br><span class="line">		&#123;size_type _N = size() + (_M &lt; size() ? size() : _M);</span><br><span class="line">		iterator _S = allocator.allocate(_N, (void *)0);</span><br><span class="line">		iterator _Q = _Ucopy(_First, _P, _S);</span><br><span class="line">		_Ufill(_Q, _M, _X);</span><br><span class="line">		_Ucopy(_P, _Last, _Q + _M);</span><br><span class="line">		_Destroy(_First, _Last);</span><br><span class="line">		allocator.deallocate(_First, _End - _First);</span><br><span class="line">		_End = _S + _N;</span><br><span class="line">		_Last = _S + size() + _M;</span><br><span class="line">		_First = _S; &#125;</span><br><span class="line">	else if (_Last - _P &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_P, _Last, _P + _M);</span><br><span class="line">		_Ufill(_Last, _M - (_Last - _P), _X);</span><br><span class="line">		fill(_P, _Last, _X);</span><br><span class="line">		_Last += _M; &#125;</span><br><span class="line">	else if (0 &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_Last - _M, _Last, _Last);</span><br><span class="line">		copy_backward(_P, _Last - _M, _Last);</span><br><span class="line">		fill(_P, _P + _M, _X);</span><br><span class="line">		_Last += _M; &#125;&#125;</span><br><span class="line">		</span><br><span class="line">void insert(iterator _P, _It _F, _It _L)</span><br><span class="line">	&#123;size_type _M = 0;</span><br><span class="line">	_Distance(_F, _L, _M);</span><br><span class="line">	if (_End - _Last &lt; _M)</span><br><span class="line">		&#123;size_type _N = size() + (_M &lt; size() ? size() : _M);</span><br><span class="line">		iterator _S = allocator.allocate(_N, (void *)0);</span><br><span class="line">		iterator _Q = _Ucopy(_First, _P, _S);</span><br><span class="line">		_Q = _Ucopy(_F, _L, _Q);</span><br><span class="line">		_Ucopy(_P, _Last, _Q);</span><br><span class="line">		_Destroy(_First, _Last);</span><br><span class="line">		allocator.deallocate(_First, _End - _First);</span><br><span class="line">		_End = _S + _N;</span><br><span class="line">		_Last = _S + size() + _M;</span><br><span class="line">		_First = _S; &#125;</span><br><span class="line">	else if (_Last - _P &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_P, _Last, _P + _M);</span><br><span class="line">		_Ucopy(_F + (_Last - _P), _L, _Last);</span><br><span class="line">		copy(_F, _F + (_Last - _P), _P);</span><br><span class="line">		_Last += _M; &#125;</span><br><span class="line">	else if (0 &lt; _M)</span><br><span class="line">		&#123;_Ucopy(_Last - _M, _Last, _Last);</span><br><span class="line">		copy_backward(_P, _Last - _M, _Last);</span><br><span class="line">		copy(_F, _L, _P);</span><br><span class="line">		_Last += _M; &#125;&#125;</span><br><span class="line">iterator erase(iterator _P)</span><br><span class="line">	&#123;copy(_P + 1, end(), _P);    // 从—_p+1开始往前挪</span><br><span class="line">	_Destroy(_Last - 1, _Last);</span><br><span class="line">	--_Last;</span><br><span class="line">	return (_P); &#125;</span><br><span class="line">iterator erase(iterator _F, iterator _L)</span><br><span class="line">	&#123;iterator _S = copy(_L, end(), _F);</span><br><span class="line">	_Destroy(_S, end());</span><br><span class="line">	_Last = _S;</span><br><span class="line">	return (_F); &#125;</span><br><span class="line">void clear()</span><br><span class="line">	&#123;erase(begin(), end()); &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">void _Destroy(iterator _F, iterator _L)</span><br><span class="line">	&#123;for (; _F != _L; ++_F)</span><br><span class="line">		allocator.destroy(_F); &#125;</span><br><span class="line">iterator _Ucopy(const_iterator _F, const_iterator _L,</span><br><span class="line">	iterator _P)</span><br><span class="line">	&#123;for (; _F != _L; ++_P, ++_F)</span><br><span class="line">		allocator.construct(_P, *_F);</span><br><span class="line">	return (_P); &#125;</span><br><span class="line">void _Ufill(iterator _F, size_type _N, const _Ty &amp;_X)</span><br><span class="line">	&#123;for (; 0 &lt; _N; --_N, ++_F)</span><br><span class="line">		allocator.construct(_F, _X); &#125;</span><br><span class="line">void _Xran() const</span><br><span class="line">	&#123;_THROW(out_of_range, "invalid vector&lt;T&gt; subscript"); &#125;</span><br><span class="line"></span><br><span class="line">size_type capacity() const //容量</span><br><span class="line">&#123;return (_First == 0 ? 0 : _End - _First); &#125;</span><br></pre></td></tr></table></figure>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/10/stl_traits/">
  <time datetime="2016-08-10T04:56:46.000Z">
    2016-08-10
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/10/stl_traits/">STL  traits</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="STL-traits的实现"><a href="#STL-traits的实现" class="headerlink" title="STL traits的实现"></a>STL traits的实现</h1><pre><code>traits 是一种能获取出你所需类型特性的方法：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> output_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> forward_iterator_tag :<span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> bidirectional_iterator_tag: <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> random_access_iterator_tag: <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Cat,<span class="keyword">class</span> _T,<span class="keyword">class</span> _Dis = <span class="keyword">int</span>,</span><br><span class="line">         <span class="keyword">class</span> _P = _T*, <span class="keyword">class</span> _Ref = _T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _Cat iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> _T   value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Dis difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> _P   pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T         value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span>       difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T *       pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T &amp;       reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator_traits&lt;<span class="keyword">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T               value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span>             difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T *       pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T &amp;       reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span><br><span class="line"><span class="title">iterator_category</span><span class="params">(Iterator &amp;)</span>			      <span class="comment">//迭代器的'类型'</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;</span><br><span class="line">	<span class="keyword">return</span> iterator_category();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span><br><span class="line"><span class="title">value_type</span><span class="params">(Iterator &amp;)</span>                       <span class="comment">//迭代器所指之物类型</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type *</span><br><span class="line"><span class="title">difference_type</span><span class="params">(Iterator &amp;)</span>                 <span class="comment">//获取差值类型</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h1><p><img src="/imgs/Summary/stl_iterator.png" alt="stl_iterator"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> output_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> forward_iterator_tag :<span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> bidirectional_iterator_tag: <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> random_access_iterator_tag: <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="advance例子"><a href="#advance例子" class="headerlink" title="advance例子"></a>advance例子</h1><p><img src="/imgs/Summary/stl_traits.png" alt="stl_traits"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/08/06/stdarg/">
  <time datetime="2016-08-06T06:33:58.000Z">
    2016-08-06
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/08/06/stdarg/">可变参函数</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p><img src="/imgs/Summary/stdargs.png" alt="stdargs"></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h2><pre><code>va_list 是一个字符指针类型。
typedef char *va_list; 
</code></pre><h2 id="va-start"><a href="#va-start" class="headerlink" title="va_start"></a>va_start</h2><p>va_start用于初始化 va_list, 取第一个参数(从左向右)的地址再向高地址偏移LASTARG大小，实际上指向了第二个参数(从左向右)</p>
<pre><code>#ifndef __sparc__
#define va_start(AP, LASTARG) \
(AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG))) //AP即va_list

#else
#define va_start(AP, LASTARG) \
(__builtin_saveregs (), \
AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))
#endif

__builtin_saveregs()是在gcc 的库程序libgcc2.c 中定义的，用于保存寄存器。
它的说明可参见gcc 手册章节“Target Description Macros”中的
“Implementing the Varargs Macros”小节。
</code></pre><h3 id="va-rounded-size"><a href="#va-rounded-size" class="headerlink" title="__va_rounded_size"></a>__va_rounded_size</h3><p>__va_rounded_size定义了取整后的TYPE 类型的字节长度值。是int 长度(4)的倍数。</p>
<pre><code>#define __va_rounded_size(TYPE) \
(((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))
</code></pre><h2 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg"></a>va_arg</h2><p>va_arg先让AP偏移到指向下一个参数的位置，再返回要取的参数</p>
<pre><code>#define va_arg(AP, TYPE) \
(AP += __va_rounded_size (TYPE), \
*((TYPE *) (AP - __va_rounded_size (TYPE))))
</code></pre><h2 id="va-end"><a href="#va-end" class="headerlink" title="va_end"></a>va_end</h2><p>va_end 必须在va_arg 读完所有的参数后再被调用。<br>va_end 可以修改AP 使其在重新调用va_start 之前不能被使用(把va_list指向NULL)。<br>    void va_end (va_list);    // 在gnulib 中定义</p>
<pre><code>#define va_end(AP)
</code></pre><h1 id="Linux内核代码Acenv-h中也定义了一组宏"><a href="#Linux内核代码Acenv-h中也定义了一组宏" class="headerlink" title="Linux内核代码Acenv.h中也定义了一组宏"></a>Linux内核代码Acenv.h中也定义了一组宏</h1><p><img src="/imgs/Summary/linux_args.png" alt="linuxstdargs"></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/23/lcs/">
  <time datetime="2016-06-23T04:18:38.000Z">
    2016-06-23
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/06/23/lcs/">最长公共子序列</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="最长公共子序列（LongestCommonSubsequence）"><a href="#最长公共子序列（LongestCommonSubsequence）" class="headerlink" title="最长公共子序列（LongestCommonSubsequence）"></a>最长公共子序列（LongestCommonSubsequence）</h1><p>一个数列S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S称为已知序列的最长公共子序列。<br>最长公共子序列问题可以由动态规划求解</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。<br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化（en:memoization）存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。————<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="external">维基百科</a></p>
<h1 id="动态规划求解LCS"><a href="#动态规划求解LCS" class="headerlink" title="动态规划求解LCS"></a>动态规划求解LCS</h1><h3 id="1-最优子结构性质"><a href="#1-最优子结构性质" class="headerlink" title="1.最优子结构性质"></a>1.最优子结构性质</h3><p>设输入序列是X [0 .. m-1] 和 Y [0 .. n-1]，长度分别为 m 和 n。和设序列 L(X [0 .. m-1]，Y[0 .. n-1]) 是这两个序列的 LCS 的长度，以下为 L(X [0 .. M-1]，Y [0 .. N-1]) 的递归定义：</p>
<pre><code>1）如果两个序列的最后一个元素匹配（即X [M-1] == Y [N-1]）
</code></pre><p>　　 则：L（X [0 .. M-1]，Y [0 .. N-1]）= 1 + L（X [0 .. M-2]，Y [0 .. N-1]）</p>
<pre><code>2）如果两个序列的最后字符不匹配（即X [M-1] != Y [N-1]）
</code></pre><p>　　 则：L(X [0 .. M-1]，Y [0 .. N-1]) = MAX(L(X [0 .. M-2]，Y [0 .. N-1])，L(X [0 .. M-1]，Y [0 .. N-2]))</p>
<h3 id="2-重叠子问题"><a href="#2-重叠子问题" class="headerlink" title="2.重叠子问题"></a>2.重叠子问题</h3><pre><code>很明显，LCS 很多子问题也都共享子子问题，因此可以对其进行递归求解。具体的算法时间度为 O(m*n)，可以优化至 O(m+n)。
</code></pre><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><p>代码如下：</p>
<h3 id="未优化"><a href="#未优化" class="headerlink" title="未优化"></a>未优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Longest_Common_Subsequence(char *sa, int n1, char *sb, int n2)</span><br><span class="line">&#123;</span><br><span class="line">	if (n1 &gt; 0 &amp;&amp; n2 &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		if (sa[n1 - 1] == sb[n2 - 1]) </span><br><span class="line">			return 1 + Longest_Common_Subsequence(sa, n1 - 1, sb, n2 - 1);</span><br><span class="line">		else </span><br><span class="line">			return max(Longest_Common_Subsequence(sa, n1 , sb, n2 - 1),</span><br><span class="line">			Longest_Common_Subsequence(sa, n1 - 1, sb, n2 ));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int lcs(char *sa, int n1, char *sb, int n2)</span><br><span class="line">&#123;</span><br><span class="line">	int **ls = new int*[n1];</span><br><span class="line">	for (int i = 0; i &lt; n1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ls[i] = new int[n2];</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; n1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 0; j &lt; n2; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i == 0 || j == 0) ls[i][j] = 0;</span><br><span class="line">			else if (sa[i - 1] == sb[j - 1]) ls[i][j] = ls[i - 1][j - 1] + 1;</span><br><span class="line">			else ls[i][j] = max(ls[i - 1][j], ls[i][j - 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int tmp = ls[n1 - 1][n2 - 1];</span><br><span class="line">	for (int k = 0; k &lt; n1; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		delete []ls[k];</span><br><span class="line">	&#125;</span><br><span class="line">	delete []ls;</span><br><span class="line">	return tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/20/C++11/">
  <time datetime="2016-06-19T17:14:38.000Z">
    2016-06-20
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/06/20/C++11/">C++11</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>auto是C++程序设计语言的关键字。自C++11以来，auto关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。–维基百科<br>auto实际上实在编译时对变量进行了类型推导，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。<br>从汇编看也是如此：<br><img src="/imgs/Summary/int.png" alt="int"><br><img src="/imgs/Summary/auto_int.png" alt="auto_int"><br>自定义类型<br><img src="/imgs/Summary/A.png" alt="A"><br><img src="/imgs/Summary/auto_A.png" alt="auto_A"><br>auto用于模板简化了模板的操作<br><img src="/imgs/Summary/auto_template.png" alt="auto_template"></p>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>它可以用于创建并定义匿名的函数对象形式如下：<br>[函数对象参数]（操作符重载函数参数） -&gt;返回值类型{函数体}(具体参数)<br><img src="/imgs/Summary/lambda.png" alt="lambda"></p>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>decltype的功能与auto相反，从变量得到类型<br><img src="/imgs/Summary/decltype.png" alt="decltype"></p>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>右值引用（rvalue reference），是C++程序设计语言自C++11标准提出的一类数据类型。用于实现移动语义（move semantic）与完美转发（perfect forwarding）。–维基百科<br>在资源转移不是调用拷贝等操作而是实现了资源的转移<br><a href="https://www.zhihu.com/question/22111546" target="_blank" rel="external">参考</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/12/stl_alloc/">
  <time datetime="2016-06-11T17:26:33.000Z">
    2016-06-12
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/06/12/stl_alloc/">STL空间配置器</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h1><p>当所申请的空间大于128bytes时，stl直接使用一级空间配置器<br>一级空间配置器其实是对malloc的封装，以及添加了类似new_handler处理内存分配不足的情况<br>当内存不足时调用oom_malloc尝试回收一些已分配的内存，调用的是__malloc_alloc_oom_handler方法(如果有的话，没有就抛出异常)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int inst&gt;</span><br><span class="line">class __malloc_alloc_template</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	static void *oom_malloc(size_t n)//</span><br><span class="line">	&#123;</span><br><span class="line">		void (*my_malloc_handler) () = NULL;</span><br><span class="line">		void *result = NULL;</span><br><span class="line">		for(;;)//不断的去尝试</span><br><span class="line">		&#123;</span><br><span class="line">			my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">			if(NULL == my_malloc_handler)</span><br><span class="line">			&#123;</span><br><span class="line">				__THROW_BAD_ALLOC;</span><br><span class="line">			&#125;else</span><br><span class="line">			&#123;</span><br><span class="line">				(*my_malloc_handler)();//调用malloc_handler</span><br><span class="line">			&#125;</span><br><span class="line">			result = malloc(n);</span><br><span class="line">			if(NULL != result)</span><br><span class="line">			&#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static void *oom_realloc(void *p,size_t n)</span><br><span class="line">	&#123;</span><br><span class="line">		void (*my_malloc_handler) () = NULL;</span><br><span class="line">		void *result = NULL;</span><br><span class="line">		for(;;)</span><br><span class="line">		&#123;</span><br><span class="line">			my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">			if(NULL == my_malloc_handler)</span><br><span class="line">			&#123;</span><br><span class="line">				__THROW_BAD_ALLOC;</span><br><span class="line">			&#125;else</span><br><span class="line">			&#123;</span><br><span class="line">				(*my_malloc_handler)();</span><br><span class="line">			&#125;</span><br><span class="line">			result = realloc(p,n);</span><br><span class="line">			if(NULL != result)</span><br><span class="line">			&#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static void (*__malloc_alloc_oom_handler)();</span><br><span class="line">public:</span><br><span class="line">	static void * allocate(size_t n)</span><br><span class="line">	&#123;</span><br><span class="line">		void * result = malloc(n);</span><br><span class="line">		if(NULL == result)</span><br><span class="line">		&#123;</span><br><span class="line">			result = oom_malloc(n);</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	static void deallocate(void *p,size_t/*n*/)</span><br><span class="line">	&#123;</span><br><span class="line">		free(p);</span><br><span class="line">	&#125;</span><br><span class="line">	static void *reallocate(void *p,size_t /*old_sz*/,size_t new_sz)</span><br><span class="line">	&#123;</span><br><span class="line">		void result = realloc(p,new_sz);</span><br><span class="line">		if(NULL == result)</span><br><span class="line">		&#123;</span><br><span class="line">			result = oom_realloc(p,new_sz);</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	// set_new_handler ;</span><br><span class="line">	static void(*set_malloc_handler(void (*f)()))() //参数和返回值全是函数指针</span><br><span class="line">	&#123;</span><br><span class="line">		void (*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">		__malloc_alloc_oom_handler = f;</span><br><span class="line">		return old;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int inst&gt;</span><br><span class="line">void (*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)()= NULL;</span><br><span class="line"></span><br><span class="line">typedef __malloc_alloc_template&lt;0&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></p>
<h1 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h1><p>二级空间配置器其实是一个内存池，他维持这一个空闲链表数组，所需字节数全上调成8的倍数，然后在空闲链表里面找。<br>当空闲链表内存块不足时，优先从已申请好的空闲堆内存中填充空闲链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>&#123;__ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span>&#123;__MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line"><span class="keyword">enum</span>&#123;__NFREELIST = __MAX_BYTES/__ALIGN&#125;;</span><br><span class="line"><span class="keyword">union</span> obj                                    <span class="comment">//链表的结构，空间的有效利用</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">union</span> obj *free_list_link;</span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> obj * <span class="keyword">volatile</span> free_list[__NFREELIST];<span class="comment">//空闲链表数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bytes + __ALIGN <span class="number">-1</span>) / __ALIGN <span class="number">-1</span>;<span class="comment">//寻找在数组中的下标位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bytes + __ALIGN <span class="number">-1</span>) &amp; ~(__ALIGN<span class="number">-1</span>);<span class="comment">//上调成8的倍数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * start_free; <span class="comment">//空闲内存起始地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * end_free;   <span class="comment">//空闲内存结束地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;  <span class="comment">//空闲堆内存大小</span></span><br></pre></td></tr></table></figure></p>
<h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><p>如果找到了则把那块空间从free_list中非配给用户，没找到则调用refill()填充free_list<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span><span class="comment">// 15</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list = <span class="literal">NULL</span>;</span><br><span class="line">	obj *result = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> malloc_alloc::allocate(n);</span><br><span class="line">	&#125;</span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">	result = *my_free_list;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == result)       <span class="comment">//如果free_list为空则调用refill填充或直接分配</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">void</span> *r = refill(ROUND_UP(n));</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	*my_free_list = result-&gt;free_list_link;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="refill"><a href="#refill" class="headerlink" title="refill"></a>refill</h2><p>STL规定refill为内存不足的那块填充20块相应大小的内存块，但是可能出现内存不足的情况所有申请到的不一定是20个内存快(可能只有1个)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="comment">//</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> *chunk = chunk_alloc(n,nobjs);<span class="comment">// 申请内存块</span></span><br><span class="line">	obj *<span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">	obj *result;</span><br><span class="line">	obj *current_obj, *next_obj;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>==nobjs) <span class="keyword">return</span> chunk;</span><br><span class="line">	my_free_list=free_list + FREELIST_INDEX(n);</span><br><span class="line">	result=(obj *)chunk;</span><br><span class="line">	*my_free_list=next_obj=(obj *)(chunk+n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;;i++)                    <span class="comment">//将剩余的块连接到空闲链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		current_obj = next_obj;</span><br><span class="line">		next_obj=(obj *)((<span class="keyword">char</span> *)next_obj + n);</span><br><span class="line">		<span class="keyword">if</span>(nobjs <span class="number">-1</span>==i)</span><br><span class="line">		&#123;</span><br><span class="line">			current_obj-&gt;free_list_link=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			current_obj-&gt;free_list_link=next_obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;                <span class="comment">//将第一个内存块返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="chunk-alloc"><a href="#chunk-alloc" class="headerlink" title="chunk_alloc"></a>chunk_alloc</h2><p>chunk_alloc函数分配内存块给free_list,他和refill是维持这个结构的核心。处理了多种内存不足的情况<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> * <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size,<span class="keyword">int</span> &amp;nobjs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> total_bytes = size*nobjs;</span><br><span class="line">	<span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line">	<span class="keyword">if</span>(bytes_left &gt;= total_bytes)<span class="comment">//当剩余内存完全足够</span></span><br><span class="line">	&#123;</span><br><span class="line">		result = start_free;</span><br><span class="line">		start_free += total_bytes;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size)<span class="comment">//内存不够分配20块但能分配一块或一块以上</span></span><br><span class="line">	&#123;</span><br><span class="line">		nobjs = bytes_left/size;</span><br><span class="line">		total_bytes = size*nobjs;</span><br><span class="line">		result = start_free;</span><br><span class="line">		start_free += total_bytes;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="comment">//剩余内存一块都不能分配</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> bytes_to_get=<span class="number">2</span> *total_bytes+ROUND_UP(heap_size&gt;&gt;<span class="number">4</span>);</span><br><span class="line">		<span class="comment">//先给剩余的内存找到合适的free list(先处理start_free——end_free的那段内存)</span></span><br><span class="line">		<span class="keyword">if</span>(bytes_left&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			obj * <span class="keyword">volatile</span> *my_free_list=free_list +FREELIST_INDEX(bytes_left);</span><br><span class="line">			((obj *)start_free)-&gt;free_list_link= *my_free_list;</span><br><span class="line">			*my_free_list=(obj *)start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向堆空间申请内存</span></span><br><span class="line">		start_free=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==start_free)<span class="comment">//堆空间不足时</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			obj *<span class="keyword">volatile</span>* my_free_list,*p;</span><br><span class="line">			<span class="comment">//遍历比他大的free list查看是否还剩有未使用内存</span></span><br><span class="line">			<span class="keyword">for</span>(i=size;i&lt;__MAX_BYTES;i+=__ALIGN)</span><br><span class="line">			&#123;</span><br><span class="line">				my_free_list = free_list +FREELIST_INDEX(i);</span><br><span class="line">				p = *my_free_list;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">0</span>!=p)<span class="comment">//</span></span><br><span class="line">				&#123;</span><br><span class="line">					*my_free_list = p -&gt;free_list_link;</span><br><span class="line">					start _free = (<span class="keyword">char</span> *)p;</span><br><span class="line">					end_free = (<span class="keyword">char</span> *)p;</span><br><span class="line">					<span class="comment">//由于nobjs 传的是引用所以递归调用修正nobjs</span></span><br><span class="line">					<span class="keyword">return</span> (chunk_alloc(size,nobjs));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			end_free=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">//调用一级空间配置器,看看malloc_handler能否挤出内存...</span></span><br><span class="line">			start_free =(<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">		&#125;</span><br><span class="line">		heap_size +=bytes_to_get;</span><br><span class="line">		end_free =start_free +bytes_to_get;			</span><br><span class="line">		<span class="keyword">return</span> (chunk_alloc(size,nobjs));<span class="comment">//同上</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p,<span class="keyword">size_t</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	obj * <span class="keyword">volatile</span> * my_free_list = <span class="literal">NULL</span>;</span><br><span class="line">	obj *q = (obj*)p;</span><br><span class="line">	<span class="keyword">if</span>(n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES)</span><br><span class="line">	&#123;</span><br><span class="line">		malloc_alloc::deallocate(p,n);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">	q-&gt;free_list_link = *my_free_list;</span><br><span class="line">	*my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p>如图：<br><img src="/imgs/Summary/stl_alloc.png" alt="二级空间配置器内存结构"><br>参考资料——STL源码剖析</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/06/heap_sort/">
  <time datetime="2016-06-06T04:18:38.000Z">
    2016-06-06
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/06/06/heap_sort/">海量数据中求最大的K个数</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在n个数中求最大的K个数</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>建立一个K个节点的小根堆，再遍历n个数<br>与小根堆的第一个元素比较</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void heap_adjust(int *arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	int tmp = arr[start];</span><br><span class="line">	for (int i = 2 * start + 1; i &lt;= end; i = i * 2 + 1)</span><br><span class="line">	&#123;</span><br><span class="line">		if (i + 1 &lt;= end &amp;&amp; arr[i]&gt;arr[i + 1])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (tmp &gt; arr[i])</span><br><span class="line">		&#123;</span><br><span class="line">			arr[start] = arr[i];</span><br><span class="line">			start = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">void heap_sort(int *arr, int length)</span><br><span class="line">&#123;</span><br><span class="line">	//调整成小根堆</span><br><span class="line">	for (int i = (length - 1 - 1) / 2; i &gt;= 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		heap_adjust(arr, i, length - 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int * find_max_N(int *arr, int len,int n)</span><br><span class="line">&#123;</span><br><span class="line">	if (arr == NULL || len &lt; n||n&lt;1)return NULL;</span><br><span class="line">	int *brr = new int[n];//先让brr为arr的前n个</span><br><span class="line">	memcpy(brr, arr, sizeof(int)* n);</span><br><span class="line">	heap_sort(brr, n);//把前n个调整为小根堆</span><br><span class="line">	for (int i = n; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if (arr[i]&gt;brr[0])//如果有值比brr[0]大，则进行赋值后再次调整</span><br><span class="line">		&#123;</span><br><span class="line">			brr[0] = arr[i];</span><br><span class="line">			heap_adjust(brr, 0, n-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return brr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用堆排序的思想，时间复杂度为O(n*logk),空间复杂度为O(K)</p>
<h1 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h1><p>使用快速排序划分的做法</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">wanyaoqi</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>